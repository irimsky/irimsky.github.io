<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[逻辑回归]]></title>
    <url>%2F2019%2F08%2F24%2F%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%2F</url>
    <content type="text"><![CDATA[在分类问题中，我们尝试预测的是结果是否属于某一个类（例如正确或错误），其往往是一个离散的值。比如：判断一封电子邮件是否是垃圾邮件；判断一次金融交易是否是欺诈。 逻辑回归算法，是用于分类问题的最广泛的学习算法。 简单二元分类 我们将因变量(dependent variable)可能属于的两个类分别称为负向类（negative class）和正向类（positive class），则因变量 y∈{0,1} ，其中 0 表示负向类，1 表示正向类。 而我们将用逻辑回归算法使得假设函数 $h_\theta(x)$ 的输出范围∈[0,1]，表示$P(y=1|x; \theta)$，即“因变量 y=1 的概率”。 注：虽然“逻辑回归”的名字中带有“回归”二字，但其仍属于分类算法。 逻辑回归 假设模型如果对如图的数据集进行线性回归的话，会得到一条直线。其结果并不能用作分类（值域不在0-1内）而逻辑回归的预测模型为： h_\theta(x) = g(\theta^TX)其中 g(z) = \frac{1}{1+e^{-z}}该函数图像如图所示：如前所言，$h_\theta(x)$ 的作用是：对于给定的输入变量，根据选择的参数计算输出变量=1的可能性，即$P(y=1|x; \theta)$例如，如果对于给定的𝑥，通过已经确定的参数计算得出$h_\theta(x)$ = 0.7，则表示有70%的几率𝑦为正向类，相应地𝑦为负向类的几率为 30% 决策边界若以0.5作为区分正向类与负向类的阈值，则可以发现：对于函数$g(z) = \frac{1}{1+e^{-z}}$，在$z]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>机器学习</tag>
        <tag>线性回归</tag>
        <tag>梯度下降</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长递增子序列（LIS）的三种算法]]></title>
    <url>%2F2019%2F08%2F16%2F%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88LIS%EF%BC%89%E7%9A%84%E4%B8%89%E7%A7%8D%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[最长递增子序列：给定一个长度为N的数组，找出一个最长的单调递增子序列，子序列不一定连续，但初始顺序不能乱。比如数组A={1,3,4,2,5}，其最长递增子序列为1,3,4,5 方法一：最长公共子序列法对于给定长度为N的数组A： 使数组B为排序后的数组A (O(NlogN)) 求出A与B的最长公共子序列(LCS) (O(N^2^)) 对求得的公共子序列进行去重 (O(N)) 例如：A = {1,3,5,4,4,6}则B = {1,3,4,4,5,6}最长公共子串C = {1,3,4,4,6}对C去重得到结果：{1,3,4,6} 方法二：动态规划法(O(N^2)) 状态$dp[i]$：以第i个数结尾的最长递增子序列的长度 状态方程：$dp[i] = dp[j]+1$ 其中 $a[j] &lt; a[i]，j &lt; i$且 $dp[j]$ 最大。若没有满足的a[j]则$dp[i]=1$ 最后max(dp)即为最长递增子序列的长度 若要求得最长递增子序列，可以用另外的数组lastidx记录上述的“j” 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;using namespace std;int main()&#123; int a[6] = &#123;1,3,5,4,4,6&#125;; int dp[6],lastidx[6]; for(int i = 0;i &lt; 6;i++) &#123; dp[i] = 1; lastidx[i] = i; for(int j = 0;j &lt; i;j++) &#123; if(a[j] &lt; a[i] &amp;&amp; dp[j] + 1 &gt; dp[i]) &#123; dp[i] = dp[j] + 1; lastidx[i] = j; &#125; &#125; &#125; int maxx = 0, maxi = 0; for(int i = 0;i &lt; 6;i++) if(dp[i]&gt;maxx) &#123; maxx = dp[i]; maxi = i; &#125; int lis[6]; for(int i=maxx-1;i&gt;0;i--) &#123; lis[i] = a[maxi]; maxi = lastidx[maxi]; &#125; cout &lt;&lt; "最长公共子串长度：" &lt;&lt; maxx &lt;&lt; endl; for(int i=0;i&lt;maxx;i++) cout &lt;&lt; lis[i] &lt;&lt; " "; return 0;&#125; 输出结果为： 最长公共子串长度：41 3 5 6 方法三：O(NlogN)算法对于给定长度N的数组a，声明数组last[N]，last[i]的意义为：长度为i的递增子序列的最后一个数字，在循环数组a时更新这个数组。 比如{1,3,5,4,4,8,6,7} a[0] = 1, 则长度为1的LIS为1，则last[1] = 1 , len = 1; a[1] = 3, 3大于此前的最后一位1，故目前的最长的LIS可以为2了，故last[2] = 3, len = 2； a[2] = 5, 同理，last[3] = 5 , len = 3; a[3] = 4, 其可以加在5和3之间，所以可以把5替换掉，即last[3] = 4; a[4] = 4,与last[3]相等了，所以不做变动。 a[5] = 8,比最后一位（5）大，所以last[4] = 8, len = 4; a[6] = 6,在5和8中间，所以last[4] = 6; a[7] = 7, 比最后一位6大，所以last[5] = 7, len =5; 最终得到结果LIS长度为：5，last数组为：1,3,4,6,7 注意last数组并不一定是LIS，而是对应长度的LIS的最后一位。&lt;/font&gt;而注意到last数组往往是有序的，所以数组元素只有替换而没有挪动，故每次插入只要用二分查找即可。因此复杂度为O(N logN) 若想得到最长递增子序列，同样可以使用数组lastidx和pre，用来标识至此为止该长度的LIS的最后一个数的下标和当前数字的来源12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;#define inf 0x3f3f3f3f#define maxn 8int main()&#123; int a[maxn] = &#123;1,3,5,4,4,8,6,7&#125;; int last[maxn], lastidx[maxn], pre[maxn], len=0, maxi; memset(last,0x3f,sizeof last); last[0] = -inf; for(int i=0;i&lt;maxn;i++) &#123; int pos = lower_bound(last, last+maxn, a[i])-last; //二分查找 last[pos] = a[i]; lastidx[pos] = i; //该长度的LIS的最后一个数的下标 pre[i] = lastidx[pos-1]; //当前数字的来源（LIS中的前一位，即lastidx[长度-1]） if(pos &gt;= len) &#123; len = pos; maxi = i; //LIS最后一个数字的下标 &#125; &#125; int lis[maxn]; cout &lt;&lt; "最长公共子串长度：" &lt;&lt; len &lt;&lt; endl; for(int i=len-1;i&gt;=0;i--) &#123; lis[i] = a[maxi]; maxi = pre[maxi]; &#125; for(int i=0;i&lt;len;i++) cout &lt;&lt; lis[i] &lt;&lt; " "; return 0;&#125; 输出： 最长公共子串长度：51 3 4 6 7]]></content>
      <categories>
        <category>ACM算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
        <tag>分治法</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PTA-最大连续子数列和（4种方法）]]></title>
    <url>%2F2019%2F07%2F29%2FPTA-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E5%88%97%E5%92%8C%EF%BC%884%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%89%2F</url>
    <content type="text"><![CDATA[题目描述给定K个整数组成的序列{ N~1~​​ ,N​~2~ , …, N​~k~​​ }，“连续子列”被定义为{ N~i​​~ , N~i+1~, …, N~j~}，其中 1≤i≤j≤K。“最大子列和”则被定义为所有连续子列元素的和中最大者。现要求你编写程序，计算给定整数序列的最大子列和。 输入格式输入第1行给出正整数n (≤100000)；第2行给出n个整数，其间以空格分隔。 输出格式在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。 样例输入126-2 11 -4 13 -5 -2 样例输出120 &lt;/br&gt; 题解方法①：暴力枚举法O(n^3^ ）最暴力的方法：用三层循环枚举所有的子数列，输出其中的最大值。123456789ans = 0;for(int i = 1; i &lt;= n; i++) for(int j = i; j &lt;= n; j++) &#123; sum = 0; for(int k = i; k &lt;= j; k++) sum += num[k]; if(sum &gt; ans) ans = sum; &#125; 稍微优化成O(n^2^)可以注意到：设sum(i)为从 a~1~ 到 a~i~ 的数列的和，sum(0)为0，则从 a~i~ 到 a~j~ 的子数列的和为sum( j ) - sum( i-1 )由此，可以将暴力枚举法的三层循环改为二层循环：12345ans = 0;for(int i = 1; i &lt;= n; i++) for(int j = i; j &lt;= n; j++) if(sum[j] - sum[i-1] &gt; ans) ans = sum[j] - sum[i-1] 方法②：二分法 O(nlogn)首先，我们可以把整个序列平均分成左右两部分，答案则会在以下三种情况中：1、所求序列完全包含在左半部分的序列中。2、所求序列完全包含在右半部分的序列中。3、所求序列刚好横跨分割点，即左右序列各占一部分。前两种情况和大问题一样，只是规模小了些，如果三个子问题都能解决，那么答案就是三个结果的最大值。 前两种情况都比较好解决，需要注意的是第三种情况怎么处理：以分割点为起点向左的最大连续序列和、以分割点为起点向右的最大连续序列和，这两个结果的和就是第三种情况的答案。因为起始点（分割点）是固定的，所以两者只需要O(n)以内的复杂度得出。 12345678910111213141516171819202122long long solve(int left, int right)&#123; int mid = (left + right) / 2; //处理第三种情况 long long suml, sumr, maxl, maxr; suml = sumr = maxl = maxr = 0; for(int i = mid; i &gt; 0; i--) &#123; suml += num[i]; if(suml&gt;maxl) maxl = suml; &#125; for(int i = mid+1; i &lt; n; i++) &#123; sumr += num[i]; if(sumr&gt;maxr) maxr = sumr; &#125; long long ans = maxr + maxl; long long lans = solve(left, mid), rans = solve(mid+1, right); //处理左右两段 ans = max(ans, lans); ans = max(ans, rans); //返回最大值 return ans;&#125; 方法③ 动态规划O(n)终极王牌方法，找到一个合适的公式，可以很快解决问题。根据连续子数列的连续这一性质，我们可以设dp[i]为以num[i]结尾的最大子数列和，则有：dp[i] = max(dp[i-1], \ \ 0)+num[i] 而最终答案则是: $max(dp[i]),i\in[1, n]$ 12345678dp[0] = 0; long long ans = 0;for(int i = 1; i &lt;= n; i++)&#123; dp[i] = max(dp[i-1], 0) + num[i]; if(dp[i] &gt; ans) ans = dp[i];&#125;cout &lt;&lt; ans; 方法④ 另一种O(n)算法由暴力法的前缀和法得到启发：以num[i]结尾的某个子数列和，是sum[i] - sum[j]（j &lt; i），则以num[i]结尾的子数列和，是sum[i] - sum[ j-1 ]，其中sum[ j-1 ]为sum[0], sum[1] , …, sum[ i-1 ]中的最小值。则我们只需要在一次遍历中维护之前的最小的sum不断更新答案即可。 1234567long long minsum = 0, ans = 0, sum = 0;for(int i = 1; i &lt;= n; i++)&#123; sum += num[i]; if(sum - minsum &gt; ans) ans = sum - minsum; if(sum &lt; minsum) minsum = sum;&#125;]]></content>
      <categories>
        <category>ACM算法</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
        <tag>分治法</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性回归的正规方程法]]></title>
    <url>%2F2019%2F07%2F28%2F%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E7%9A%84%E6%AD%A3%E8%A7%84%E6%96%B9%E7%A8%8B%E6%B3%95%2F</url>
    <content type="text"><![CDATA[正规方程 正规方程是通过求解下面的方程来找出使得代价函数最小的参数的： $\frac{\partial}{\partial \theta_j} J(\theta_i) = 0$ 假设我们的训练集特征矩阵为 $X$（包含了 𝑥0 = 1）并且我们的训练集结果为向量 $y$，则利用正规方程解出向量 \theta = (X^TX)^{-1}X^Ty 比如如下的数据： X = \begin{bmatrix} 1 & 2104 & 5 & 1 & 45\\ 1 & 1416 & 3 & 2 & 40\\ 1 & 1534 & 3 & 2 & 30 \\ 1 & 852 & 2 & 1 & 36 & \\ \end{bmatrix}y = \begin{bmatrix} 460\\ 232\\ 315\\ 178\\ \end{bmatrix}正规方程的Python实现：12345import numpy as np def normalEqn(X, y): theta = np.linalg.inv(X.T@X)@X.T@y #X.T@X等价于 X.T.dot(X) return theta 与梯度下降比较 梯度下降 正规方程 需要选择学习率𝛼 不需要 需要多次迭代 一次运算得出 当特征数量𝑛大时也能较好适用 需要计算$(X^TX)^-1$。如果特征数量𝑛较大则 运算代价大，因为矩阵逆的计算时间复杂度 为𝑂(𝑛3) 适用于各种类型的模型 只适用于线性模型，不适合逻辑回归模型等其他模型 矩阵不可逆时的情况 $(X^TX)$会出现不可逆的情况。原因可能有： 有多余的特征变量成了线性相关关系比如一个特征是厘米单位的长度，而另一个特征是毫米单位的长度，两列数据在自乘之后成了100倍的线性关系。这时就需要把多余的特征量删除。 有太多的特征量（m &lt;&lt; n） 有时还会导致‘过拟合(overfit)’的现象比如m = 10, n = 100时的情况，则需要在10个训练样本中找出101个参数，这是一种比较复杂且容易出问题的任务。解决方法有：①删除一些特征量②正则化 附：正则方程推导过程 J(\theta_0,\theta_1,\dots,\theta_n) = \frac {1}{2m}\sum_{i=1}^{m}\ (h_\theta(x^{(i)}) - y^{(i)})^2转化为矩阵表示则有： J(\theta) = \frac{1}{2} (X\theta-y)^T(X\theta-y)\ \ \ \ \ \ = \frac{1}{2} (\theta^TX^T-y^T)(X\theta-y)\ \ \ \ \ \ = \frac{1}{2} (\theta^TX^TX\theta-\theta^TX^Ty-y^TX\theta + y^Ty)接下来对$\theta$求偏导。要用到几个矩阵求导法则：$\frac{dAB}{dB} = A^T$、$\frac{dA^TXA}{dX}=2AX$ 所以有： \frac{\partial}{\partial \theta} J(\theta) = \frac{1}{2}(2X^TX\theta - X^Ty -(y^TX)^T+0)= (X^TX\theta - X^Ty)令其=0，可得： \theta = (X^TX)^{-1}X^Ty]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>机器学习</tag>
        <tag>线性回归</tag>
        <tag>梯度下降</tag>
        <tag>正规方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记(十)：迭代器和生成器]]></title>
    <url>%2F2019%2F07%2F25%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%81-%EF%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[迭代器和生成器 迭代是Python最强大的功能之一，是访问集合元素的一种方式。 迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。 迭代器是一个可以记住遍历的位置的对象。 迭代其实for .. in ..循环遍历的过程就是迭代（iteration）。其他语言诸如C语言，迭代都是通过下标索引。所以可以看出，Python的for循环迭代抽象程度比其他语言高，不论有没有下标，只要是可迭代对象（后文有介绍），都可以通过它迭代，比如字典。 迭代器迭代器有两个基本的方法：iter() 和 next()。iter()用于创建一个迭代器对象next()将参数中的迭代器进行一次迭代，并返回迭代器中的元素1234567891011121314&gt;&gt;&gt; list = [1, 2, 3]&gt;&gt;&gt; l1 = iter(list)&gt;&gt;&gt; l1&lt;list_iterator object at 0x000001D5E98476A0&gt;&gt;&gt;&gt; next(l1)1&gt;&gt;&gt; next(l1)2&gt;&gt;&gt; next(l1)3&gt;&gt;&gt; next(l1)Traceback (most recent call last): File "&lt;input&gt;", line 1, in &lt;module&gt;StopIteration 迭代器到达结尾时，如果再调用next()，则会无法返回值而报错StopIteration。 为自定义类创建迭代器把一个类作为一个迭代器使用需要在类中实现两个方法 __iter__() 与 __next__() 。123456789101112131415161718192021class my_nums(): def __iter__(self): self.a = 1 return self def __next__(self): if self.a &lt; 20: x = self.a self.a += 1 return x else: raise StopIterationmn = my_nums()l1 = iter(mn)print(next(l1))print(next(l1))print(next(l1))for i in mn: print(i, end=' ') 1231 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 定义过两个方法后的类的对象便成了可迭代对象，可以对其调用iter()和next()以及对其进行for循环遍历 StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在__next__() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。 生成器通过列表生成式，我们可以直接创建一个列表，但是，受到内存限制，列表容量肯定是有限的，而且创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。 所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间，在Python中，这种一边循环一边计算的机制，称为生成器(generator)。 （转自廖雪峰） 生成器是一个特殊的程序，可以被用作控制循环的迭代行为，Python中生成器是迭代器的一种。 延迟计算或惰性求值 (Lazy evaluation)迭代器不要求你事先准备好整个迭代过程中所有的元素。仅仅是在迭代至某个元素时才计算该元素，而在这之前或之后，元素可以不存在或者被销毁。这个特点使得它特别适合用于遍历一些巨大的或是无限的集合。 创建生成器的方法有很多。 列表生成器回忆列表解析的内容。1squares = [x ** 2 for x in range(10)] 第一种创建生成器的方法是：只要把一个列表解析式的[]改成()，就创建了一个generator：123456&gt;&gt;&gt; L = [x ** 2 for x in range(10)]&gt;&gt;&gt; L[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]&gt;&gt;&gt; g = (x ** 2 for x in range(10))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt; 如上所言，生成器就是迭代器，他可以被next()调用。1234567&gt;&gt;&gt; g = (x ** 2 for x in range(10))&gt;&gt;&gt; next(g)0&gt;&gt;&gt; next(g)1&gt;&gt;&gt; next(g)4 但是我们很少对生成器使用next()，大多数情况都是使用for循环，因为生成器也是个可迭代对象&lt;/font&gt;。123g = (x ** 2 for x in range(10))for i in g: print(i, end=', ') 0, 1, 4, 9, 16, 25, 36, 49, 64, 81 生成器函数另一个方法是：生成器函数。在 Python 中，使用了 yield 的函数被称为生成器函数（generator function）。跟普通函数不同的是，生成器函数是一个返回迭代器的函数，只能用于迭代操作。 12345678910111213def odd(): print('step 1') yield 1 print('step 2') yield 3 print('step 3') yield 5o = odd()print(next(o))print(next(o))print(next(o))print(next(o)) step 11step 23step 35Traceback (most recent call last): File “D:/Pytest/1.py”, line 48, in print(next(o))StopIteration 在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。比如上述函数： odd()返回的是一个迭代器，传递给变量o 第一次调用next()：先打印step 1 ，再返回1，保存信息并停止运行函数。 第二次调用next()：函数从原先停止的地方继续，先打印step 2， 再返回3，保存信息并停止。 第三次调用next()：… 第四次调用next()：函数已到达末尾，无法返回值，报错StopIteration 同理，生成器函数可以用for循环迭代：123456789101112131415# 例1 输出奇数def odd(n): cnt = 0 while cnt &lt; n: yield cnt * 2 + 1 cnt += 1for i in odd(5): print(i)o = odd(4)for i in o: print(i) 135791357 我们将刚才的odd函数改编了一下，使其可以用传递参数来控制其循环次数。 1234567891011121314151617# 例2 杨辉三角形def triangle(): a = [1] while True: yield a a = [1] + [a[i]+a[i-1] for i in range(1, len(a))] + [1]n = 0results = []for t in triangle(): print(t) results.append(t) n = n + 1 if n == 10: break [1][1, 1][1, 2, 1][1, 3, 3, 1][1, 4, 6, 4, 1][1, 5, 10, 10, 5, 1][1, 6, 15, 20, 15, 6, 1][1, 7, 21, 35, 35, 21, 7, 1][1, 8, 28, 56, 70, 56, 28, 8, 1][1, 9, 36, 84, 126, 126, 84, 36, 9, 1] 上述代码在for循环中控制迭代次数。 可迭代对象只要是实现了__iter__()或__getitem__()方法的对象，就可以使用迭代器进行访问。 序列：字符串、列表、元组 非序列：字典、文件 自定义类：用户自定义的类实现了__iter__()或__getitem__()方法的对象 生成器或者生成器函数可以使用isinstance()判断一个对象是否是Iterable可迭代对象： 1234567891011&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance([], Iterable) # 列表True&gt;&gt;&gt; isinstance(&#123;&#125;, Iterable) # 字典True&gt;&gt;&gt; isinstance('abc', Iterable) # 字符串True&gt;&gt;&gt; isinstance((x for x in range(10)), Iterable) # 这个是生成器True&gt;&gt;&gt; isinstance(100, Iterable) # 普通数字False 可迭代≠是迭代器。除了生成器既是迭代器，也是可迭代对象，其他的可迭代对象都需要iter()来获取其迭代器。]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多元梯度下降]]></title>
    <url>%2F2019%2F07%2F24%2F%E5%A4%9A%E5%85%83%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%2F</url>
    <content type="text"><![CDATA[多元线性回归 - 符号解释： $n$：特征的个数$x^{(i)}$：第i个训练样本$x^{(i)}_{j}$：第$i$个训练样本的第$j$个特征值 预测函数： h_\theta(x) = \theta_0 +\theta_1x_1 + \theta_2x_2 + ...+\theta_nx_n为了方便，我们定义$x_0=1$ x = \begin{bmatrix} x_0\\ x_1\\ x_2\\ \vdots\\ x_n \end{bmatrix}\theta = \begin{bmatrix} \theta_0\\ \theta_1\\ \theta_2\\ \vdots\\ \theta_n \end{bmatrix}则有h_\theta(x) = \theta_0 x_0+\theta_1x_1 + \theta_2x_2 + ...+\theta_nx_n = \theta^T·x\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 多元梯度下降 预测函数：h_\theta(x) = \theta^T·x =\theta_0 x_0+\theta_1x_1 + \theta_2x_2 + ...+\theta_nx_n代价函数：J(\theta_0,\theta_1,\dots,\theta_n) = \frac{1}{2m}\sum_{i=1}^{m}{(h_\theta(x^{(i)})-y^{(i)})^2} 梯度下降算法： Repeat\{ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \\theta_j := \theta_j - \alpha \frac{\partial}{\partial \theta_j}J(\theta_0, \theta_1,\dots,\theta_n) \ \ \ for\ j = 0,1,\dots,n\}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \求导得： Repeat\{ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \\theta_j := \theta_j - \alpha \frac {1}{m} \sum ^{m}_{i=1}(h_\theta(x^{(i)})-y^{(i)})·x_j^{(i)}\}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 梯度下降法实践1：特征缩放 在我们面对多维特征问题的时候，我们要保证这些特征都具有相近的尺度，这将帮助梯度下降算法更快地收敛。 比如以房价问题为例，假设我们使用两个特征，房屋的尺寸和房间的数量，尺寸的值为 02000 平方英尺，而房间数量的值则是 0-5，以两个参数分别为横纵坐标，绘制代价函数的等高线图能，看出图像会显得很扁，梯度下降算法需要非常多次的迭代才能收敛。 特征缩放是一种有效的解决方法：尝试将所有特征的尺度都尽量缩放到-1 到 1 之间。如图：最简单的方法是令 x_n' = \frac{x_n - \mu_n}{s_n}其中，$\mu_n$是平均值，$s_n$是标准差，或者极差（最大值减最小值）。 梯度下降法实践2: 学习率α 梯度下降算法收敛所需要的迭代次数根据模型的不同而不同，我们不能提前预知，我们可以绘制迭代次数和代价函数的图表来观测算法需要几次迭代趋于收敛。$J(\theta)$应该在每次迭代后都减少。我们也可以设置：当一次迭代后减少的值小于特定阈值时停止。 梯度下降算法的每次迭代受到学习率的影响 如果学习率𝑎过小，则达到收敛所需的迭代次数会非常高； 如果学习率𝑎过大，每次迭代可能不会减小代价函数，可能会越过局部最小值导致无法收敛。 通常使用这些学习率：𝛼 = 0.01，0.03，0.1，0.3，1，3，10 Python代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import numpy as npimport matplotlib.pyplot as pltimport pandas as pdimport seaborn as snsdf = pd.read_csv('ex1data2.txt', names=['size', 'rooms', 'price'])# print(df.head())def normalize_feature(df): return df.apply(lambda column: (column - column.mean()) / column.std())#特征缩放df = normalize_feature(df)def get_X(df): ones = pd.DataFrame(&#123;'ones': np.ones(len(df))&#125;) data = pd.concat([ones, df], axis=1) return data.iloc[:, :-1].as_matrix()def get_y(df): return np.array(df.iloc[:, -1].as_matrix())X = get_X(df)y = get_y(df)m = X.shape[0]n = X.shape[1]theta = np.zeros(n)def lr_cost(theta, X, y): inner = (X.dot(theta) - y) cost = inner.T.dot(inner) return cost/(2 * m)def gradient(theta, X, y): inner = X.T.dot(X.dot(theta) - y) return inner/mdef batch_gradient(theta, X, y, epoch, alpha=0.01): _theta = theta.copy() cost_data = [lr_cost(theta, X, y)] for _ in range(epoch): _theta = _theta - alpha * gradient(_theta, X, y) cost_data.append(lr_cost(_theta, X, y)) return _theta, cost_dataepoch = 500final_theta, cost_data = batch_gradient(theta, X, y, epoch)print(final_theta)sns.tsplot(time=np.arange(len(cost_data)), data=cost_data)plt.xlabel('epoch', fontsize=18)plt.ylabel('cost', fontsize=18)plt.show()]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>机器学习</tag>
        <tag>线性回归</tag>
        <tag>梯度下降</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python练手项目（1）Pygame制作游戏]]></title>
    <url>%2F2019%2F07%2F17%2FPython%E7%BB%83%E6%89%8B%E9%A1%B9%E7%9B%AE%EF%BC%881%EF%BC%89Pygame%E5%88%B6%E4%BD%9C%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[背景部分 创建Pygame窗口以及响应用户输入12345678910111213141516171819202122# invasion.pyimport sysimport pygamedef run_game(): # 初始化游戏并创建一个屏幕对象 pygame.init() screen = pygame.display.set_mode((1200, 700)) pygame.display.set_caption("Thunder") # 开始游戏的主循环 while True: for event in pygame.event.get(): if event.type == pygame.QUIT: sys.exit() # 让最近绘制的屏幕可见 pygame.display.flip()run_game() 首先我们导入模块pygame和sys。sys用于退出游戏 游戏以函数run_game()开头。 pygame.init()用于初始化游戏背景。 pygame.display.set_mode()用于创建一个名为screen的显示窗口。实参(1200,700)是一个元组，指定游戏窗口的尺寸。 对象screen是一个surface。在Pygame中，surface是屏幕的一部分，用于显示游戏元素（比如外星人、飞船），游戏中每个元素都是一个surface。激活游戏的动画循环后，每经过一次循环都将重新绘制这个surface。 为访问Pygame侦听到的时间，我们使用方法pygame.event.get()。所有的键盘和鼠标事件都将促使for循环运行。比如玩家点击窗口的关闭按钮时，将检测到pygame.QUIT事件，我们就调用sys.exit()来退出游戏。 pygame.display.flip()命令Pygame让最近绘制的屏幕可见。它在每次执行while循环时都会绘制一个空屏幕，并擦去旧屏幕。 绘制背景色12# 在while循环中加入如下语句： screen.fill((230,230,230)) Pygame中，颜色是以RGB值表示的。 创建设置类1234567891011#settings.pyclass Settings(): """存储游戏所有设置的类""" def __init__(self): """初始化游戏的设置""" # 屏幕设置 self.screen_width = 1200 self.screen_length = 700 self.bg_color = (230, 230, 230) 将所有游戏的设置存储在这个类中， 则invasion.py可修改：12345678910111213141516171819202122232425262728import sysimport pygamefrom settings import Settingsdef run_game(): # 初始化游戏并创建一个屏幕对象 pygame.init() sett = Settings() screen = pygame.display.set_mode( (sett.screen_length, sett.screen_width) ) pygame.display.set_caption("Thunder") # 开始游戏的主循环 while True: for event in pygame.event.get(): if event.type == pygame.QUIT: sys.exit() screen.fill(sett.bg_color) # 让最近绘制的屏幕可见 pygame.display.flip()run_game() 飞船部分 添加飞船图像就选用书配套的素材吧 创建Ship类123456789101112131415161718import pygameclass Ship(): def __init__(self, screen): self.screen = screen self.image = pygame.image.load("ship.bmp") self.rect = self.image.get_rect() self.screen_rect = screen.get_rect() self.rect.centerx = self.screen_rect.centerx self.rect.bottom = self.screen_rect.bottom def blitme(self): """在指定位置绘制飞船""" self.screen.blit(self.image, self.rect) 在屏幕上绘制飞船在invasion.py中创建飞船对象，并调用其方法blitme()：12345678910111213141516171819202122232425262728293031import sysimport pygamefrom settings import Settingsfrom ship import Shipdef run_game(): # 初始化游戏并创建一个屏幕对象 pygame.init() sett = Settings() screen = pygame.display.set_mode( (sett.screen_width, sett.screen_length) ) pygame.display.set_caption("Thunder") ship = Ship(screen) # 开始游戏的主循环 while True: for event in pygame.event.get(): if event.type == pygame.QUIT: sys.exit() screen.fill(sett.bg_color) ship.blitme() # 让最近绘制的屏幕可见 pygame.display.flip()run_game() 运行后结果： 重构:game_function模块 函数check_events()我们把管理事件的代码移到一个名为check_events()的函数里，以简化run_game()12345678910#game_function.pyimport sysimport pygamedef check_events(): for event in pygame.event.get(): if event.type == pygame.QUIT: sys.exit() 函数update_screen()为进一步简化run_game()，将更新屏幕的代码移到一个名为update_screen()的函数里，并将函数定义放在game_function中12345def update_screen(sett, screen, ship): screen.fill(sett.bg_color) ship.blitme() # 让最近绘制的屏幕可见 pygame.display.flip() &lt;/br&gt; 飞船移动部分 响应按键每当用户按键时，都在Pygame里注册一个事件。事件都是通过方法pygame.event.get()获取的，因此在函数check_events()中，我们需要制定检查哪些类型的事件。每次按键都被注册一个KEYDOWN事件。检测到该事件后，我们需要检查是否按下了特定的键，执行特定的操作。比如按下右键后，要让飞船向右移动。1234567def check_events(ship): for event in pygame.event.get(): if event.type == pygame.QUIT: sys.exit() elif event.type == pygame.KEYDOWN: if event.key == pygame.K_RIGHT: ship.rect.centerx += 1 我们在参数列表里加入了ship,因为需要能够访问到飞船内部的属性。 允许不断移动玩家按住→键是希望飞船不停移动，直到松开为止。我们可以让游戏检测pygame.KEYUP事件，然后结合KEYUP和KEYDOWN事件实现持续移动。12345678# ship.py def __init__(self, screen): ... self.right_move = False def update(self): if self.right_move: self.rect.centerx += 1 在飞船的类内初始化时多添了一个属性移动标志变量right_move多添了一个方法update()，用于检查该标志变量，实现飞船属性更新：这个变量为True时，飞船就会向右移动。而这个标志变量会因KEYDOWN变为True，因KEYUP变为False，以此来实现持续移动 同时，要在invasion.py的while循环里调用update()方法：12345# invasion.py while True: gf.check_events(ship) ship.update() gf.update_screen(sett, screen, ship) 左右移动只需照着向右移动就能做出向左移动 调整飞行速度每次执行while循环，飞船最多移动1像素。但可以在settings模块里加入属性ship_speed，用于控制飞船的速度。 1234567891011# settings.pyclass Settings(): """存储游戏所有设置的类""" def __init__(self): """初始化游戏的设置""" # 屏幕设置 self.screen_width = 1200 self.screen_length = 700 self.bg_color = (230, 230, 230) self.ship_speed = 0.7 同时在ship.py中修改：12345678910111213141516class Ship(): def __init__(self, sett, screen): ... self.center = float(self.rect.centerx) ... ... def update(self): if self.right_move: self.center += sett.ship_speed if self.left_move: self.center -= sett.ship_speed self.rect.centerx = self.center 在init（）的形参中加入了setting类的sett，让飞船的方法update()可以获取其速度设置。 rect只存储整数，所以我们新建一个属性center，用flota()将rect.centerx转化成小数存储到center中。更新center之后，再根据它来更新控制飞船位置的rect.centerx（虽然centerx只存储self.center的整数部分，但对于显示飞船而言问题不大。） 限制飞船活动范围为了防止飞船飞出屏幕外，我们在飞船位置变更前添加if语句判断飞船是否将飞出框外。123456# ship.py def update(self): if self.right_move and self.rect.right &lt; self.screen_rect.right: self.center += self.sett.ship_speed if self.left_move and self.rect.left &gt; 0: self.center -= self.sett.ship_speed 如果rect的左/右边缘没有触及屏幕左/右边缘，才可以移动。 重构check_event()123456789101112131415161718192021222324# game_function.pydef check_keydown(event, ship): if event.key == pygame.K_RIGHT: ship.right_move = True elif event.key == pygame.K_LEFT: ship.left_move = Truedef check_keyup(event, ship): if event.key == pygame.K_RIGHT: ship.right_move = False elif event.key == pygame.K_LEFT: ship.left_move = Falsedef check_events(ship): for event in pygame.event.get(): if event.type == pygame.QUIT: sys.exit() elif event.type == pygame.KEYDOWN: check_keydown(event, ship) elif event.type == pygame.KEYUP: check_keyup(event, ship) 子弹部分添加子弹设置在setting.py中添加新类Bullet所需的值：123456789def __init__(self): """初始化游戏的设置""" # 屏幕设置 ... # 子弹设置 self.bullet_speed = 1 self.bullet_width = 3 self.bullet_height = 15 self.bullet_color = (60, 60, 60) 创建Bullet类123456789101112131415161718192021# bullet.pyimport pygamefrom pygame.sprite import Spriteclass Bullet(Sprite): """一个对飞船的子弹管理的类""" def __init__(self, sett, screen, ship): """在飞船处创建一个子弹对象""" super(Bullet, self).__init__() self.screen = screen self.rect = pygame.Rect(0, 0, sett.bullet_width, sett.bullet_height) self.rect.centerx = ship.rect.centerx self.rect.top = ship.rect.top self.y = float(self.rect.y) self.color = sett.bullet_color self.speed_factor = sett.bullet_speed 子弹并非基于图像，因此我们必须使用pygame.Rect()类从空白开始创建一个矩形。创建这个类的实例时，必须提供矩形左上角的x坐标和y坐标，还有宽度和高度。我们先在（0，0）处创建一个矩形，并在接下来放在正确的位置，这个位置取决于飞船的位置。 接下来编写update()和draw_bullet方法12345678def update(self): """向上移动子弹""" self.y -= self.speed self.rect.y = self.y def draw_bullet(self): pygame.draw.rect(self.screen, self.color, self.rect) 将子弹存到编组中在玩家每次按下空格时都射出一发子弹。首先我们在invasion.py中创建一个编组（Group）用于存储所有子弹，以便能够管理发射出去的子弹。这个编组是pygame.sprite.Group类的一个实例；Group类 类似于列表，但提供了有助于游戏开发的功能。在主循环中，我们使用这个编组在屏幕上绘制子弹，更新每一个子弹的位置。12345678910111213141516171819202122import sysimport pygameimport game_function as gffrom pygame.sprite import Groupfrom settings import Settingsfrom ship import Shipdef run_game(): # 初始化游戏并创建一个屏幕对象 ... bullets = Group() # 开始游戏的主循环 while True: gf.check_events(sett, screen, ship, bullets) ship.update() bullets.update() gf.update_screen(sett, screen, ship, bullets)run_game() 我们将bullets作为实参传递给了check_events()和update_screen()。在check_event（）中我们要用空格处理bullets；在update_screen中则要更新绘制到屏幕上的bullets。当你对编组调用update()时，编组将自动对每一个”精灵”调用update()，即对每一个子弹。 开火因为只有在按下空格键时飞船才会开火，所以我们只需修改check_keydown_events()而不用修改keyup12345678910111213141516171819202122232425262728# game_function.pyfrom bullet import Bulletdef check_keydown(event, sett, screen, ship, bullets): if event.key == pygame.K_RIGHT: ship.right_move = True elif event.key == pygame.K_LEFT: ship.left_move = True elif event.key == pygame.K_SPACE: new_bullet = Bullet(sett, screen, ship) bullets.add(new_bullet)def check_events(sett, screen, ship, bullets): for event in pygame.event.get(): if event.type == pygame.QUIT: sys.exit() elif event.type == pygame.KEYDOWN: check_keydown(event, sett, screen, ship, bullets) elif event.type == pygame.KEYUP: check_keyup(event, ship)def update_screen(sett, screen, ship, bullets): screen.fill(sett.bg_color) ship.blitme() for bullet in bullets: bullet.draw_bullet() # 让最近绘制的屏幕可见 pygame.display.flip() 删除已经消失的子弹我们需要将已经飞出屏幕的子弹删除，减少内存负担。为此，我们需要在每次更新子弹位置后，检测rect的bottom属性小于0的子弹，并删除它们。 123456789101112# invasion.py while True: gf.check_events(sett, screen, ship, bullets) ship.update() bullets.update() for bullet in bullets.copy(): if bullet.rect.bottom &lt;= 0: bullets.remove(bullet) print(len(bullets)) gf.update_screen(sett, screen, ship, bullets) 在for循环中，不应从列表或编组中删除条目，因此必须是遍历编组的副本，故需要调用方法copy()，返回一个编组的副本。 输出编组的长度，即有效子弹的数量，是为了显示子弹的数量，核实已消失的子弹确实被删除了。 子弹效果如图： 限制子弹数量多数同类型游戏里面都会有对子弹数量的限制，鼓励玩家有目标地射击。我们在此限制子弹最大数量为4. 首先在Setting类里设置允许的最大子弹数： 123456789101112 #setting.py class Settings(): """存储游戏所有设置的类""" def __init__(self): """初始化游戏的设置""" # 屏幕设置 ... # 子弹设置 ... self.bullet_allowed = 4 在check_keydown_event()中检测到空格前，添加if语句判断子弹数量(群组长度)是否已经超过最大限制。1234567891011# game_function.pydef check_keydown(event, sett, screen, ship, bullets): if event.key == pygame.K_RIGHT: ship.right_move = True elif event.key == pygame.K_LEFT: ship.left_move = True elif event.key == pygame.K_SPACE: if len(bullets) &lt; sett.bullet_allowed: new_bullet = Bullet(sett, screen, ship) bullets.add(new_bullet) 重构bullet函数我们可以把子弹更新函数和删除子弹的代码写进一个函数update_bullet()里：12345678# game_function.pydef update_bullet(bullets): bullets.update() for bullet in bullets.copy(): if bullet.rect.bottom &lt;= 0: bullets.remove(bullet) print(len(bullets)) 故主循环里的代码可简化：12345678# invasion.py while True: gf.check_events(sett, screen, ship, bullets) ship.update() gf.update_bullet(bullets) gf.update_screen(sett, screen, ship, bullets) 同时，把检查子弹数量是否超额的代码已经添加新子弹的代码整合进一个fire_bullet()函数里：1234567891011121314# game_function.pydef fire_bullet(sett, screen, ship, bullets): if len(bullets) &lt; sett.bullet_allowed: new_bullet = Bullet(sett, screen, ship) bullets.add(new_bullet)def check_keydown(event, sett, screen, ship, bullets): if event.key == pygame.K_RIGHT: ship.right_move = True elif event.key == pygame.K_LEFT: ship.left_move = True elif event.key == pygame.K_SPACE: fire_bullet(sett, screen, ship, bullets) 外星人部分 创建Alien类123456789101112131415161718192021222324252627# alien.pyimport pygamefrom pygame.sprite import Spriteclass Alien(Sprite): """单个外星人的类""" def __init__(self, sett, screen): super().__init__() self.screen = screen self.setting = sett # 加载外星人图像，设置rect属性 self.image = pygame.image.load('alien.bmp') self.rect = self.image.get_rect() # 每个外星人最初都在屏幕左上角 self.rect.x = self.rect.width self.rect.y = self.rect.height # 存储外星人准确位置 self.x = float(self.rect.x) def blitme(self): self.screen.blit(self.image, self.rect) 创建Alien实例1234567891011121314# invasion.pydef run_game(): # 初始化游戏并创建一个屏幕对象 ... alien = Alien(sett, screen) ... # 开始游戏的主循环 while True: ... gf.update_screen(sett, screen, ship, alien, bullets) # update_screen里调用 alien.blitme()run_game() 创建一群外星人确定一行可以容纳多少外星人我们要根据屏幕水平宽度确定一行可容纳多少外星人。我们要在屏幕两边留下边距，把它设置为外星人图像的宽度。所以放置外星人的水平空间为： available_space_x = sett.screen_width - (2 * alien_width) 外星人之间还得留下空间，设置为一个外星人的宽度。因此一行可容纳的外星人数量： number_aliens_x = available_space_x / (2 * alien_width) 创建多行外星人为创建一行外星人，首先在invasion.py中创建一个名为aliens的空编组，用于存储全部外星人，再调用game_function.py中的创建外星人群的函数：12345678910111213# invasion.py...ship = Ship(sett, screen) bullets = Group() aliens = Group() aliens = Group() gf.create_fleet(sett, screen, aliens) # 开始游戏的主循环 while True: ... gf.update_screen(sett, screen, ship, aliens, bullets) 1234567891011121314151617181920212223242526# game_function.pydef create_fleet(sett, screen, aliens): """创建外星人群""" # 创建一个外星人，并计算一行可容纳多少外星人 alien = Alien(sett, screen) alien_width = alien.rect.width available_space_x = sett.screen_width - 2 * alien_width number_aliens_x = int(available_space_x / (2 * alien_width)) # 创建第一行外星人 for alien_number in range(number_aliens_x): # 创建一个外星人并加入群组 alien = Alien(sett, screen) alien.x = alien_width + 2 * alien_width * alien_number alien.rect.x = alien.x aliens.add(alien)def update_screen(sett, screen, ship, aliens, bullets): ... ... aliens.draw(screen) ... # 让最近绘制的屏幕可见 ... 效果如图： 重构create_fleet() 为create_fleet()新添两个函数create_alien()和get_number_aliens_x() 1234567891011121314151617181920212223242526# game_function.pydef get_number_aliens_x(sett, alien_width): available_space_x = sett.screen_width - 2 * alien_width number_aliens_x = int(available_space_x / (2 * alien_width)) return number_aliens_xdef create_alien(sett, screen, aliens, alien_width, alien_number): # 创建一个外星人并加入群组 alien = Alien(sett, screen) alien.x = alien_width + 2 * alien_width * alien_number alien.rect.x = alien.x aliens.add(alien)def create_fleet(sett, screen, aliens): """创建外星人群""" # 创建一个外星人，并计算一行可容纳多少外星人 alien = Alien(sett, screen) alien_width = alien.rect.width number_aliens_x = get_number_aliens_x(sett, alien_width) # 创建第一行外星人 for alien_number in range(number_aliens_x): create_alien(sett, screen, aliens, alien_width, alien_number) 添加行要创建外星人群，需要计算屏幕可容纳多少行，并对创建一行外星人的循环重复相应的次数。为计算可容纳的行数，我们将屏幕高度减去第一行的外星人的上边距（外星人高度）、飞船的高度以及最初外星人高度加上外星人边距： available_space_y = sett.screen_height - 3*alien_height - ship_height 这样可以给飞船上方留出一定空白区域。 每行下方都要留出一定的空白区域，并将其设置为外星人的高度。为计算可容纳的行数，我们将可用垂直空间除以外星人高度的两倍： number_rows = available_space_y /(2 * alien_height) 123456789101112131415161718192021222324# game_funtion.pydef get_nuber_rows(sett, alien_height, ship_height): available_space_y = sett.screen_length - 3 * alien_height - ship_height number_rows = int(available_space_y / (2 * alien_height)) return number_rowsdef create_alien(sett, screen, aliens, alien_width, alien_number, row_number): # 创建一个外星人并加入群组 ... alien.rect.y = alien.rect.height + 2 * alien.rect.height * row_number ...def create_fleet(sett, screen, ship, aliens): """创建外星人群""" # 创建一个外星人，并计算一行可容纳多少外星人 ... number_rows = get_nuber_rows(sett, alien_height, ship.rect.height) # 创建第一行外星人 for row_number in range(number_rows): for alien_number in range(number_aliens_x): create_alien(sett, screen, aliens, alien_width, alien_number, row_number) 移动外星人让外星人向右移动为移动外星人，我们将使用alien.py中的方法update()，且对外星人群中的每个外星人都调用它。首先添加一个外星人移动速度的设置：123456789101112# setting.pyclass Settings(): """存储游戏所有设置的类""" def __init__(self): """初始化游戏的设置""" # 屏幕设置 ... # 子弹设置 ... self.alien_speed = 1 然后在Alien类里实现update()：12345# alien.py def update(self): self.x += self.setting.alien_speed self.rect.x = self.x 接着在game_function.py里编写update_aliens()1234# game_function.pydef update_aliens(aliens): aliens.update() aliens编组将自动对每一个外星人调用update()。 在主循环里调用update_aliens(aliens):123456while True: gf.check_events(sett, screen, ship, bullets) ship.update() gf.update_bullet(bullets) gf.update_aliens(aliens) gf.update_screen(sett, screen, ship, aliens, bullets) 创建表示外星人移动方向的设置让外星人在撞到屏幕右边缘后会向下移动，再向左移动，代码如下：1234567# setting.pyself.alien_speed = 1self.alien_drop_speed = 10# 下降速度self.fleet_direction = 1# 1表示向右，-1表示向左, 可以直接作为速度的系数用于坐标运算 检查外星人是否撞到边缘检查外星人是否撞到边缘，为类Alien编写方法check_edges()：12345678# alien.py def check_edges(self): screen_rect = self.screen.get_rect() if self.rect.right &gt;= screen_rect.right: return True elif self.rect.left &lt;= screen_rect.left: return True 同时修改update():123def update(self): self.x += self.setting.alien_speed * self.setting.fleet_direction self.rect.x = self.x 向下移动并改变移动方向有一个外星人到达屏幕边缘时，需要将整群外星人下移并转向。所以我们需要对game_function.py做大修改，因为我们需要检查每一个外星人是不是已经到了边缘。为此我们编写check_fleet_edge()和change_fleet_dir()1234567891011121314151617181920# game_function.pydef change_fleet_dir(sett, aliens): """将整群外星人下移""" for alien in aliens: alien.rect.y += sett.alien_drop_speed sett.fleet_direction *= -1def check_fleet_edges(sett, aliens): """有一个外星人到达边缘""" for alien in aliens.sprites(): if alien.check_edges(): change_fleet_dir(sett, aliens) breakdef update_aliens(sett, aliens): check_fleet_edges(sett, aliens) aliens.update() 同时修改主循环中update_aliens()的参数：1gf.update_aliens(sett, aliens) 射杀外星人检测子弹与外星人的碰撞子弹击中外星人时，我们要让外星人消失。为此我们需要在更新子弹位置后判断其是否碰撞。 我们用sprite.groupcollide()方法来检测两个群组的成员是否有碰撞。它将每颗子弹的rect同每个外星人的rect进行比较，并返回一个字典，其中包含发生碰撞的子弹和外星人。在这个字典中，每个键都是一颗子弹，而对应的值都是被击中的外星人。（这个字典在之后计分要用到）12345# game_function.pydef update_bullets(aliens, bullets): ... collisions = pygame.sprite.groupcollide(bullets, aliens, True, True) 这行代码先遍历每颗子弹再遍历每个外星人，每当有两者rect重叠，它就在返回的字典中添加一对键值对。最后两个实参告诉pygame删除发生碰撞的子弹和外星人（第一个true表示子弹会被删除，如果改为false则子弹碰撞时不会被删除，而是一直飞到屏幕外） 接着要在invasion.py中的update_bullets()参数中添加aliens。 生成新的外星人群当一个外星人群被消灭后，应该再出现另一群外星人。我们先检查编组aliens是否为空，如果为空，就调用create_fleet()。我们将在update_bullets()中进行这个检查，因为外星人都是在这里被消灭的123456# game_function.pydef update_bullets(sett, screen, ship, aliens, bullets): ... if len(aliens) == 0: create_fleet(sett, screen, ship, aliens) 同时要修改invasion.py中update_bullets的参数。 重构update_bullets()123456789101112131415# game_function.pydef check_bullet_collision(sett, screen, ship, bullets, aliens): collisions = pygame.sprite.groupcollide(bullets, aliens, True, True) if len(aliens) == 0: create_fleet(sett, screen, ship, aliens)def update_bullet(sett, screen, ship, bullets, aliens): bullets.update() for bullet in bullets.copy(): if bullet.rect.bottom &lt;= 0: bullets.remove(bullet) print(len(bullets)) check_bullet_collision(sett, screen, ship, bullets, aliens) 结束游戏需要添加失败事件：外星人撞到飞船，或者有外星人降到屏幕底端，飞船将会被摧毁，玩家用光生命树后游戏结束。 检测飞船与外星人碰撞12345678# game_function.pydef update_aliens(sett, ship, aliens): check_fleet_edges(sett, aliens) aliens.update() if pygame.sprite.spritecollideany(ship, aliens): print("shit!") 方法spritecollideany()接受两个实参：一个精灵和一个编组。它检查编组是否有其他成员与精灵发生了碰撞，并在找到与精灵发生碰撞的成员后停止遍历，返回True. 如果没有碰撞则返回None。 响应外星人与飞船碰撞飞船与外星人碰撞后：飞船生命-1、全屏外星人和子弹清空并暂停一段时间后出现新的外星人群。 寻找编写一个用于跟踪游戏统计信息的新类—Gamestats, 并将其保存为文件stats. py ：1234567891011# stats.pyclass Gamestats(): def __init__(self, sett): self.sett = sett self.reset_stats() self.active = False def reset_stats(self): self.life = 1 同时在invasion.py中创建一个名为stats的实例12sett = Settings()stats = Gamestats(sett) 接着编写飞船碰撞时的响应：123456789101112131415161718192021# game_function.pydef ship_hit(sett, stats, screen, ship, aliens, bullets): stats.life -= 1 aliens.empty() bullets.empty() create_fleet(sett, screen, ship, aliens) ship.center = screen.get_rect().centerx # 将飞船调整至中心位置 sleep(0.5)def update_aliens(sett, stats, screen, ship, aliens, bullets): check_fleet_edges(sett, aliens) aliens.update() if pygame.sprite.spritecollideany(ship, aliens): ship_hit(sett, stats, screen, ship, aliens, bullets) 同时要在invasion.py中修改update_aliens()参数列表 有外星人到达底部为此我们写一个函数check_alien_bottom()1234567891011121314# game_function.pydef alien_bottom(sett, stats, screen, ship, aliens, bullets): screen_rect = screen.get_rect() for alien in aliens: if alien.rect.bottom &gt;= screen_rect.bottom: ship_hit(sett, stats, screen, ship, aliens, bullets) def update_aliens(sett, stats, screen, ship, aliens, bullets): check_fleet_edges(sett, aliens) aliens.update() if pygame.sprite.spritecollideany(ship, aliens) or alien_bottom(sett, stats, screen, ship, aliens, bullets): ship_hit(sett, stats, screen, ship, aliens, bullets) 游戏结束 当life减为0后，游戏结束。我们在GameStats里添加一个作为标志的属性active，以便在玩家的飞船用完后结束游戏：1234567891011# stats.pyclass Gamestats(): def __init__(self, sett): self.sett = sett self.life = 3 self.active = True def reset_stats(self): self.life = 3 self.active = True 当玩家的生命减为0时，该变量变为false12345678910111213141516# game_function.pydef ship_hit(sett, stats, screen, ship, aliens, bullets): stats.life -= 1 if stats.life&gt;0: aliens.empty() bullets.empty() create_fleet(sett, screen, ship, aliens) ship.center = screen.get_rect().centerx sleep(0.5) else: stats.active = False 添加PLAY按钮添加PLAY按钮，让程序开始时处于非活动状态，则要修改stats.py中的代码123456789class Gamestats(): def __init__(self, sett): self.sett = sett self.life = 3 self.active = False def reset_stats(self): self.life = 3 创建Button类由于pygame没有内置创建按钮的方法，所以我们创建一个Button类123456789101112131415161718192021222324252627282930313233# button.pyimport pygame.fontclass Button(): def __init__(self, sett, screen, msg): self.screen = screen self.screen_rect = screen.get_rect() self.width, self.height = 200, 50 self.button_color = (0, 255, 0) self.text_color = (255, 255, 255) self.font = pygame.font.SysFont(None, 48) # 指定字体字号来渲染文字 self.rect = pygame.Rect(0, 0, self.width, self.height) self.rect.center = self.screen_rect.center # 将字符串渲染成图像 self.prep_msg(msg) def prep_msg(self, msg): """将字符串渲染成图像""" # 第二个布尔参数是反锯齿开关 self.msg_image = self.font.render(msg, True, self.text_color, self.button_color) self.msg_image_rect = self.msg_image.get_rect() self.msg_image_rect.center = self.rect.center def draw_button(self): self.screen.fill(self.button_color, self.rect) self.screen.blit(self.msg_image, self.msg_image_rect) 在屏幕上绘制按钮只需要一个Play按钮，故我们直接在invasion.py中创建1234567891011121314151617...from button import Buttondef run_game(): # 初始化游戏并创建一个屏幕对象 ... pygame.display.set_caption("Thunder") play_button = Button(sett, screen, 'PLAY') ... # 开始游戏的主循环 while True: ... gf.update_screen(sett, screen, stats, ship, aliens, bullets, play_button)run_game() 接着修改game_function.py的update_screen，以便在游戏处于非活动状态时显示按钮123456def update_screen(sett, screen, stats, ship, aliens, bullets, button): ... if not stats.active: button.draw_button() # 让最近绘制的屏幕可见 pygame.display.flip() 一定要把draw放在flip前面，这样才能让绘制完所有其他元素之后再绘制按钮，然后切换到新屏幕。 开始游戏在按下按钮时开始新游戏，需要对鼠标事件进行监视。在game_function.py中添加如下代码：12345678910111213141516def check_play(stats, button, mouseX, mouseY): if button.rect.collidepoint(mouseX, mouseY): stats.active = Truedef check_events(sett, screen, stats, button, ship, bullets): for event in pygame.event.get(): if event.type == pygame.QUIT: sys.exit() elif event.type == pygame.KEYDOWN: check_keydown(event, sett, screen, ship, bullets) elif event.type == pygame.KEYUP: check_keyup(event, ship) elif event.type == pygame.MOUSEBUTTONDOWN: mouse_X, mouse_Y = pygame.mouse.get_pos() check_play(stats, button, mouse_X, mouse_Y) 重置游戏游戏结束后，会再显示PLAY按钮。每次单击它都应该重置整个游戏，重置统计信息，删除现有的外星人和子弹，创建新的外星人，让飞船居中。1234567891011121314151617181920212223def check_play(sett, screen, stats, button, ship, aliens, bullets, mouseX, mouseY): if button.rect.collidepoint(mouseX, mouseY): stats.reset_stats() stats.active = True aliens.empty() bullets.empty() create_fleet(sett, screen, ship, aliens) ship.center = screen.get_rect().centerxdef check_events(sett, screen, stats, button, ship, aliens, bullets): for event in pygame.event.get(): if event.type == pygame.QUIT: sys.exit() elif event.type == pygame.KEYDOWN: check_keydown(event, sett, screen, ship, bullets) elif event.type == pygame.KEYUP: check_keyup(event, ship) elif event.type == pygame.MOUSEBUTTONDOWN: mouse_X, mouse_Y = pygame.mouse.get_pos() check_play(sett, screen, stats, button, ship, aliens, bullets, mouse_X, mouse_Y) 将Play按钮切换到非活动状态有一个问题是，即使在游戏活动状态，按钮图形不会显示，但是点击其原来的位置依然会重置游戏。所以要在监视鼠标事件时添加一个if条件：123def check_play(sett, screen, stats, button, ship, aliens, bullets, mouseX, mouseY): if button.rect.collidepoint(mouseX, mouseY) and not stats.active: ... 隐藏光标在点击Play后的游戏活动状态，鼠标光标应该被隐藏1234567891011def check_play(sett, screen, stats, button, ship, aliens, bullets, mouseX, mouseY): if button.rect.collidepoint(mouseX, mouseY) and not stats.active: pygame.mouse.set_visible(False) stats.reset_stats() stats.active = True aliens.empty() bullets.empty() create_fleet(sett, screen, ship, aliens) ship.center = screen.get_rect().centerx 并在游戏结束后重现它：12345678def ship_hit(sett, stats, screen, ship, aliens, bullets): stats.life -= 1 if stats.life &gt; 0: ... else: pygame.mouse.set_visible(True) stats.active = False 提高难度随着游戏的进行，游戏的难度应当得到提升。 修改速度设置我们要通过提高游戏整体速度来提升难度，所以飞船、子弹、外星人的速度是在变的。为此我们可以将settting里的设置属性分为静态和动态两部分。1234567891011121314151617181920212223242526class Settings(): """存储游戏所有设置的类""" def __init__(self): """初始化游戏的设置""" # 屏幕设置 self.screen_width = 1200 self.screen_length = 700 self.bg_color = (230, 230, 230) # 子弹设置 self.bullet_width = 3 self.bullet_height = 15 self.bullet_color = (60, 60, 60) self.bullet_allowed = 4 self.speed_scale = 1.1 # 速度提升率 self.init_dynamic() def init_dynamic(self): self.alien_speed = 1 self.alien_drop_speed = 10 # 下降速度 self.fleet_direction = 1 # 1表示向右，-1表示向左, 可以直接作为速度的系数用于坐标运算 self.bullet_speed = 2 self.ship_speed = 1.5 接着编写提升速度的方法increase_speed()1234def increase_speed(self): self.alien_speed *= self.speed_scale self.bullet_speed *= self.speed_scale self.ship_speed *= self.speed_scale 并在每消灭一群外星人时调用一次这个方法：12345def check_bullet_collision(sett, screen, ship, bullets, aliens): collisions = pygame.sprite.groupcollide(bullets, aliens, True, True) if len(aliens) == 0: create_fleet(sett, screen, ship, aliens) sett.increase_speed() 重置速度每次开始新游戏时，速度都要重置一次1234def check_play(sett, screen, stats, button, ship, aliens, bullets, mouseX, mouseY): if button.rect.collidepoint(mouseX, mouseY) and not stats.active: ... sett.init_dynamic() 记分在stats类里添加一个属性记录得分12345678910class Gamestats(): def __init__(self, sett): self.sett = sett self.reset_stats() self.active = False def reset_stats(self): self.life = 1 self.score = 0 显示得分为了在屏幕上显示得分，我们首先创建一个新类scoreboard：12345678910111213141516171819202122232425import pygame.fontclass ScoreBoard(): def __init__(self, sett, screen, stats): self.screen = screen self.screen_rect = screen.get_rect() self.sett = sett self.stats = stats self.text_color = (30, 30, 30) self.font = pygame.font.SysFont(None, 48) self.prep_score() def prep_score(self): score_str = str(self.stats.score) self.score_image = self.font.render(score_str, True, self.text_color, self.sett.bg_color) self.score_rect = self.score_image.get_rect() self.score_rect.right = self.screen_rect.right - 20 self.score_rect.top = 20 def show_score(self): self.screen.blit(self.score_image, self.score_rect) 创建记分牌实例1234567891011121314151617...from scoreboard import ScoreBoarddef run_game(): # 初始化游戏并创建一个屏幕对象 ... sb = ScoreBoard(sett, screen, stats) ... # 开始游戏的主循环 while True: ... gf.update_screen(sett, screen, stats, sb, ship, aliens, bullets, play_button)run_game() 同时要在update_screen()中调用show_score() 得分击杀外星人后要增加分数。只需要检查子弹击中外星人时返回的字典（collision）即可.我们现在setting中设置一个外星人的得分。1234def __init__(self): """初始化游戏的设置""" ... self.alien_score = 50 接着在check_bullet_collision()中检查字典。（这个字典的键是一颗子弹，值是被这颗子弹击中的外星人列表）1234567def check_bullet_collision(sett, screen, stats, sb, ship, bullets, aliens): collisions = pygame.sprite.groupcollide(bullets, aliens, True, True) ... if collisions: for aliens in collisions.key(): stats.score += sett.alien_score * len(aliens) sb.prep_score() 主循环中要修改update_bullets()的参数 提高点数随着游戏难度提升，一个外星人的得分应当提高。所以在setting中增加一个得分提升的幅度属性1self.score_scale = 1.5 在游戏难度提升时，即速度提高时，修改setting的属性alien_score（因为alien_score会变动，所以要把这个属性分类为动态，使其在动态初始化方法中被赋初值）12345678910111213141516class Settings(): """存储游戏所有设置的类""" def __init__(self): """初始化游戏的设置""" ... self.init_dynamic() def init_dynamic(self): ... self.alien_score = 50 def increase_speed(self): ... self.alien_score = int(self.alien_score * self.score_scale) 将得分圆整大部分游戏都会将游戏得分显示为10的整倍数。我们可以把得分圆整。123456# scoreboard.py def prep_score(self): rounded_score = int(round(self.stats.score, -1)) score_str = "&#123;:,&#125;".format(rounded_score) ... round()的第二个参数为精确到的小数位。第二个参数为负数，则round()将圆整到最近的10、100、1000等整倍数。 &quot;{:,}&quot;.format(rounded_score)为一个字符串格式设置指令，它让Python将数值转换成字符串时在其中插入逗号。 最高分我们在stats中增加一个属性最高分，并将其展示在屏幕顶端中央。但是为了让数据保存，这个最高分存储在外部文件中，所以每次都需要从外部文件读入：1234567class Gamestats(): def __init__(self, sett): self.sett = sett self.reset_stats() with open("highScore.txt", 'r') as hs: self.high_score = int(hs.read()) 每当一场游戏结束后，都要更新最高分：1234567891011def ship_hit(sett, stats, screen, ship, aliens, bullets): stats.life -= 1 if stats.life &gt; 0: ... else: pygame.mouse.set_visible(True) stats.active = False if stats.score &gt; stats.high_score: stats.high_score = stats.score 每次关闭前都要在外部文件更新最高分：1234567def check_events(sett, screen, stats, button, ship, aliens, bullets): for event in pygame.event.get(): if event.type == pygame.QUIT: with open("highScore.txt", 'w') as hs: hs.write(str(stats.high_score)) sys.exit() ... 接着要在最顶端显示最高分：12345678910111213141516171819202122232425# scoreboard.pyclass ScoreBoard(): def __init__(self, sett, screen, stats): ... self.prep_score() self.prep_high() def prep_score(self): ... def prep_high(self): high_score_str = "&#123;:,&#125;". format(self.stats.high_score) print(high_score_str) self.high_score_image = self.font.render(high_score_str, True, self.text_color, self.sett.bg_color) self.high_score_rect = self.high_score_image.get_rect() self.high_score_rect.centerx = self.screen_rect.centerx self.high_score_rect.top = self.screen_rect.top def show_score(self): self.screen.blit(self.score_image, self.score_rect) self.screen.blit(self.high_score_image, self.high_score_rect) 同时，在更新过最高分之后调用prep_high()：1234567891011def ship_hit(sett, stats, screen, ship, sb, aliens, bullets): stats.life -= 1 if stats.life &gt; 0: ... else: pygame.mouse.set_visible(True) stats.active = False if stats.score &gt; stats.high_score: stats.high_score = stats.score sb.prep_high() 用到ship_hit()的地方都要修改参数 奖励子弹我们新增一个机制，当玩家分数达到一定程度后，我们将接下来的3发子弹的宽度提高100倍，提高消灭外星人的效率。 首先，现在stats.py中设置奖励标准：12345678910class Gamestats(): def __init__(self, sett): ... def reset_stats(self): ... self.award_level = 1 # 奖励等级 self.bullet_award = False # 奖励状态 self.award_b = 0 # 已用奖励子弹数量 self.award_score = 1500 # 奖励分数标准 因为外星人的分数会随着游戏难度增加而增加，所以奖励分数标准应该在每一次奖励后增加。所以我们在setting.py中增加一个属性award_score_scale：12345678910111213141516171819class Settings(): """存储游戏所有设置的类""" def __init__(self): """初始化游戏的设置""" # 屏幕设置 self.screen_width = 1200 self.screen_length = 700 self.bg_color = (230, 230, 230) # 子弹设置 self.bullet_width = 3 self.bullet_height = 15 self.bullet_color = (60, 60, 60) self.bullet_allowed = 4 self.speed_scale = 1.1 # 速度提升率 self.score_scale = 1.5 self.award_score_scale = 1.4 # 分数提升率 接着，在game_funciton.py中编写判断函数：1234567def award(sett, stats): if stats.score &gt;= stats.award_level * stats.award_score: stats. bullet_award = True sett.bullet_width = 300 stats.award_level += 1 stats.award_b = 0 stats.award_score *= sett.award_score_scale 每此奖励完之后，奖励等级（award_level）要提升，奖励分数标准（award_score）要提升，已用奖励子弹数（award_b）清零。 然后要让奖励状态在三发子弹后变回False。因为子弹是在按下空格后发射，所以我们可以在检测空格事件的函数中实现： 1234567891011121314151617def award_check(sett, stats): if stats.bullet_award: if stats.award_b == 3: stats.bullet_award = False sett.bullet_width = 3 stats.award_b += 1def check_keydown(event, sett, screen, stats, ship, bullets): if event.key == pygame.K_RIGHT: ship.right_move = True elif event.key == pygame.K_LEFT: ship.left_move = True elif event.key == pygame.K_SPACE: if stats.bullet_award: award_check(sett, stats) fire_bullet(sett, screen, ship, bullets) 因为奖励状态是随着得分转变的，所以我们在得分的函数里调用award()，即check_bullet_collision()：12345678910def check_bullet_collision(sett, screen, stats, sb, ship, bullets, aliens): collisions = pygame.sprite.groupcollide(bullets, aliens, True, True) if len(aliens) == 0: create_fleet(sett, screen, ship, aliens) sett.increase_speed() if collisions: for aliens in collisions.values(): stats.score += sett.alien_score * len(aliens) sb.prep_score() award(sett, stats) 左上角显示剩余生命最后，我们来显示玩家还剩多少艘飞船，但用的是图形而不是数字。首先，需要让Ship继承Sprite，以便创建飞船编组：123456789import pygamefrom pygame.sprite import Spriteclass Ship(Sprite): def __init__(self, sett, screen): ... super().__init__() 接着在scoreboard. py 中，创建一个可供显示的飞船编组。12345678910111213def show_score(self): self.screen.blit(self.score_image, self.score_rect) self.screen.blit(self.high_score_image, self.high_score_rect) self.ships.draw(self.screen)def prep_ship(self): """显示剩余飞船""" self.ships = Group() for ship_num in range(self.stats.life): ship = Ship(self.sett, self.screen) ship.rect.x = 10 + ship_num * ship.rect.width ship.rect.y = 10 self.ships.add(ship) 要在游戏开始时显示这个剩余生命，所以我们在开始新游戏时调用prep_ships()。这个将在check_play()中进行：12345def check_play(sett, screen, stats, button, ship, sb, aliens, bullets, mouseX, mouseY): if button.rect.collidepoint(mouseX, mouseY) and not stats.active: ... sb.prep_score() sb.prep_ship() 同时，当损失生命值时，左上角的生命牌需要更新，要在ship_hit()中还要调用prep_ship()12345678910def ship_hit(sett, stats, screen, ship, sb, aliens, bullets): stats.life -= 1 if stats.life &gt; 0: ... else: .... sb.prep_ship() 别忘了对对相关函数的参数列表修改 最后的重构 将清屏和重新创建舰队的代码编写为一个函数clear_recreate() 将点击PLAY按钮后的分数板和动态设置重置的函数整合为restart() 将scoreboard .py中的init()调用的prep方法整合 最终代码：12345678910111213141516171819202122232425262728293031323334# ship.pyimport pygamefrom pygame.sprite import Spriteclass Ship(Sprite): def __init__(self, sett, screen): self.screen = screen self.sett = sett self.image = pygame.image.load("ship.bmp") self.rect = self.image.get_rect() self.screen_rect = screen.get_rect() self.rect.centerx = self.screen_rect.centerx self.rect.bottom = self.screen_rect.bottom self.center = float(self.rect.centerx) self.right_move = False self.left_move = False super().__init__() def blitme(self): """在指定位置绘制飞船""" self.screen.blit(self.image, self.rect) def update(self): if self.right_move and self.rect.right &lt; self.screen_rect.right: self.center += self.sett.ship_speed if self.left_move and self.rect.left &gt; 0: self.center -= self.sett.ship_speed self.rect.centerx = self.center 1234567891011121314151617181920212223242526272829303132333435363738# alien.pyimport pygamefrom pygame.sprite import Spriteclass Alien(Sprite): """单个外星人的类""" def __init__(self, sett, screen): super().__init__() self.screen = screen self.setting = sett # 加载外星人图像，设置rect属性 self.image = pygame.image.load('alien.bmp') self.rect = self.image.get_rect() # 每个外星人最初都在屏幕左上角 self.rect.x = self.rect.width self.rect.y = self.rect.height # 存储外星人准确位置 self.x = float(self.rect.x) def blitme(self): self.screen.blit(self.image, self.rect) def check_edges(self): screen_rect = self.screen.get_rect() if self.rect.right &gt;= screen_rect.right: return True elif self.rect.left &lt;= screen_rect.left: return True def update(self): self.x += self.setting.alien_speed * self.setting.fleet_direction self.rect.x = self.x 123456789101112131415161718192021222324252627282930# bullet.pyimport pygamefrom pygame.sprite import Spriteclass Bullet(Sprite): """一个对飞船的子弹管理的类""" def __init__(self, sett, screen, ship): super().__init__() self.screen = screen self.rect = pygame.Rect(0, 0, sett.bullet_width, sett.bullet_height) self.rect.centerx = ship.rect.centerx self.rect.top = ship.rect.top self.y = float(self.rect.y) self.color = sett.bullet_color self.speed = sett.bullet_speed def update(self): """向上移动子弹""" self.y -= self.speed self.rect.y = self.y def draw_bullet(self): pygame.draw.rect(self.screen, self.color, self.rect) 12345678910111213141516171819202122232425262728293031323334353637383940# setting.pyclass Settings(): """存储游戏所有设置的类""" def __init__(self): """初始化游戏的设置""" # 屏幕设置 self.screen_width = 1200 self.screen_length = 700 self.bg_color = (230, 230, 230) # 子弹设置 self.bullet_width = 3 self.bullet_height = 15 self.bullet_color = (60, 60, 60) self.bullet_allowed = 4 self.speed_scale = 1.1 # 速度提升率 self.score_scale = 1.5 self.award_score_scale = 1.4 # 分数提升率 self.awared_width = 300 # 奖励宽度 self.init_dynamic() def init_dynamic(self): self.alien_speed = 1 self.alien_drop_speed = 10 # 下降速度 self.fleet_direction = 1 # 1表示向右，-1表示向左, 可以直接作为速度的系数用于坐标运算 self.bullet_speed = 2 self.ship_speed = 1.5 self.alien_score = 50 def increase_speed(self): self.alien_speed *= self.speed_scale self.bullet_speed *= self.speed_scale self.ship_speed *= self.speed_scale self.alien_score = int(self.alien_score * self.score_scale) 123456789101112131415161718# stats.pyclass Gamestats(): def __init__(self, sett): self.sett = sett self.reset_stats() with open("highScore.txt", 'r') as hs: self.high_score = int(hs.read()) def reset_stats(self): self.life = 3 self.score = 0 self.active = False self.award_level = 1 self.bullet_award = False self.award_b = 0 self.award_score = 1500 123456789101112131415161718192021222324252627282930313233# button.pyimport pygame.fontclass Button(): def __init__(self, sett, screen, msg): self.screen = screen self.screen_rect = screen.get_rect() self.width, self.height = 200, 50 self.button_color = (0, 255, 0) self.text_color = (255, 255, 255) self.font = pygame.font.SysFont(None, 48) # 指定字体字号来渲染文字 self.rect = pygame.Rect(0, 0, self.width, self.height) self.rect.center = self.screen_rect.center # 将字符串渲染成图像 self.prep_msg(msg) def prep_msg(self, msg): """将字符串渲染成图像""" # 第二个布尔参数是反锯齿开关 self.msg_image = self.font.render(msg, True, self.text_color, self.button_color) self.msg_image_rect = self.msg_image.get_rect() self.msg_image_rect.center = self.rect.center def draw_button(self): self.screen.fill(self.button_color, self.rect) self.screen.blit(self.msg_image, self.msg_image_rect) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# scoreboard.pyimport pygame.fontfrom pygame.sprite import Groupfrom ship import Shipclass ScoreBoard(): def __init__(self, sett, screen, stats): self.screen = screen self.screen_rect = screen.get_rect() self.sett = sett self.stats = stats self.text_color = (30, 30, 30) self.font = pygame.font.SysFont(None, 48) self.prep_image() def prep_image(self): self.prep_score() self.prep_high() self.prep_ship() def prep_score(self): rounded_score = int(round(self.stats.score, -1)) score_str = "&#123;:,&#125;".format(rounded_score) self.score_image = self.font.render(score_str, True, self.text_color, self.sett.bg_color) self.score_rect = self.score_image.get_rect() self.score_rect.right = self.screen_rect.right - 20 self.score_rect.top = 20 def prep_high(self): high_score_str = "&#123;:,&#125;". format(self.stats.high_score) self.high_score_image = self.font.render(high_score_str, True, self.text_color, self.sett.bg_color) self.high_score_rect = self.high_score_image.get_rect() self.high_score_rect.centerx = self.screen_rect.centerx self.high_score_rect.top = self.screen_rect.top def show_score(self): self.screen.blit(self.score_image, self.score_rect) self.screen.blit(self.high_score_image, self.high_score_rect) self.ships.draw(self.screen) def prep_ship(self): """显示剩余飞船""" self.ships = Group() for ship_num in range(self.stats.life): ship = Ship(self.sett, self.screen) ship.rect.x = 10 + ship_num * ship.rect.width ship.rect.y = 10 self.ships.add(ship) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204# game_function.pyimport sysimport pygamefrom bullet import Bulletfrom alien import Alienfrom time import sleepdef fire_bullet(sett, screen, ship, bullets): if len(bullets) &lt; sett.bullet_allowed: new_bullet = Bullet(sett, screen, ship) bullets.add(new_bullet)def get_number_aliens_x(sett, alien_width): available_space_x = sett.screen_width - 2 * alien_width number_aliens_x = int(available_space_x / (2 * alien_width)) return number_aliens_xdef get_nuber_rows(sett, alien_height, ship_height): available_space_y = sett.screen_length - 3 * alien_height - ship_height number_rows = int(available_space_y / (2 * alien_height)) return number_rowsdef create_alien(sett, screen, aliens, alien_width, alien_number, row_number): # 创建一个外星人并加入群组 alien = Alien(sett, screen) alien.x = alien_width + 2 * alien_width * alien_number alien.rect.y = alien.rect.height + 2 * alien.rect.height * row_number alien.rect.x = alien.x aliens.add(alien)def create_fleet(sett, screen, ship, aliens): """创建外星人群""" # 创建一个外星人，并计算一行可容纳多少外星人 alien = Alien(sett, screen) alien_width = alien.rect.width alien_height = alien.rect.height number_aliens_x = get_number_aliens_x(sett, alien_width) number_rows = get_nuber_rows(sett, alien_height, ship.rect.height) # 创建第一行外星人 for row_number in range(number_rows): for alien_number in range(number_aliens_x): create_alien(sett, screen, aliens, alien_width, alien_number, row_number)def award_check(sett, stats): if stats.bullet_award: if stats.award_b == 3: stats.bullet_award = False sett.bullet_width = 3 stats.award_b += 1def check_keydown(event, sett, screen, stats, ship, bullets): if event.key == pygame.K_RIGHT: ship.right_move = True elif event.key == pygame.K_LEFT: ship.left_move = True elif event.key == pygame.K_SPACE: if stats.bullet_award: award_check(sett, stats) fire_bullet(sett, screen, ship, bullets)def check_keyup(event, ship): if event.key == pygame.K_RIGHT: ship.right_move = False elif event.key == pygame.K_LEFT: ship.left_move = Falsedef clear_recreate(sett, screen, ship, aliens, bullets): """清除屏幕重新开始""" aliens.empty() bullets.empty() create_fleet(sett, screen, ship, aliens) ship.center = screen.get_rect().centerxdef restart(sett, sb): sett.init_dynamic() sb.prep_score() sb.prep_ship()def check_play(sett, screen, stats, button, ship, sb, aliens, bullets, mouseX, mouseY): if button.rect.collidepoint(mouseX, mouseY) and not stats.active: pygame.mouse.set_visible(False) stats.reset_stats() stats.active = True clear_recreate(sett, screen, ship, aliens, bullets) restart(sett, sb)def check_events(sett, screen, stats, button, ship, sb, aliens, bullets): for event in pygame.event.get(): if event.type == pygame.QUIT: with open("highScore.txt", 'w') as hs: hs.write(str(stats.high_score)) sys.exit() elif event.type == pygame.KEYDOWN: check_keydown(event, sett, screen, stats, ship, bullets) elif event.type == pygame.KEYUP: check_keyup(event, ship) elif event.type == pygame.MOUSEBUTTONDOWN: mouse_X, mouse_Y = pygame.mouse.get_pos() check_play(sett, screen, stats, button, ship, sb, aliens, bullets, mouse_X, mouse_Y)def check_bullet_collision(sett, screen, stats, sb, ship, bullets, aliens): collisions = pygame.sprite.groupcollide(bullets, aliens, True, True) if len(aliens) == 0: create_fleet(sett, screen, ship, aliens) sett.increase_speed() if collisions: for aliens in collisions.values(): stats.score += sett.alien_score * len(aliens) sb.prep_score() award(sett, stats)def update_bullet(sett, screen, stats, sb, ship, bullets, aliens): bullets.update() for bullet in bullets.copy(): if bullet.rect.bottom &lt;= 0: bullets.remove(bullet) check_bullet_collision(sett, screen, stats, sb, ship, bullets, aliens)def update_screen(sett, screen, stats, sb, ship, aliens, bullets, button): screen.fill(sett.bg_color) ship.blitme() sb.show_score() aliens.draw(screen) for bullet in bullets: bullet.draw_bullet() if not stats.active: button.draw_button() # 让最近绘制的屏幕可见 pygame.display.flip()def change_fleet_dir(sett, aliens): """将整群外星人下移""" for alien in aliens: alien.rect.y += sett.alien_drop_speed sett.fleet_direction *= -1def check_fleet_edges(sett, aliens): """有一个外星人到达边缘""" for alien in aliens.sprites(): if alien.check_edges(): change_fleet_dir(sett, aliens) breakdef alien_bottom(sett, stats, screen, ship, sb, aliens, bullets): screen_rect = screen.get_rect() for alien in aliens: if alien.rect.bottom &gt;= screen_rect.bottom: ship_hit(sett, stats, screen, ship, sb, aliens, bullets)def ship_hit(sett, stats, screen, ship, sb, aliens, bullets): stats.life -= 1 if stats.life &gt; 0: clear_restart(sett, screen, ship, aliens, bullets) sleep(0.5) else: pygame.mouse.set_visible(True) stats.active = False if stats.score &gt; stats.high_score: stats.high_score = stats.score sb.prep_high() sb.prep_ship()def update_aliens(sett, stats, screen, ship, sb, aliens, bullets): check_fleet_edges(sett, aliens) aliens.update() if pygame.sprite.spritecollideany(ship, aliens) or alien_bottom(sett, stats, screen, ship, sb, aliens, bullets): ship_hit(sett, stats, screen, ship, sb, aliens, bullets)def award(sett, stats): if stats.score &gt;= stats.award_level * stats.award_score: stats. bullet_award = True sett.bullet_width = sett.awared_width stats.award_level += 1 stats.award_b = 0 stats.award_score *= sett.award_score_scale 12345678910111213141516171819202122232425262728293031323334353637383940# invasion.pyimport pygameimport game_function as gffrom pygame.sprite import Groupfrom settings import Settingsfrom ship import Shipfrom stats import Gamestatsfrom button import Buttonfrom scoreboard import ScoreBoarddef run_game(): # 初始化游戏并创建一个屏幕对象 pygame.init() sett = Settings() stats = Gamestats(sett) screen = pygame.display.set_mode( (sett.screen_width, sett.screen_length) ) pygame.display.set_caption("Thunder") play_button = Button(sett, screen, 'PLAY') ship = Ship(sett, screen) bullets = Group() aliens = Group() sb = ScoreBoard(sett, screen, stats) gf.create_fleet(sett, screen, ship, aliens) # 开始游戏的主循环 while True: gf.check_events(sett, screen, stats, play_button, ship, sb, aliens, bullets) ship.update() gf.update_bullet(sett, screen, stats, sb, ship, bullets, aliens) gf.update_aliens(sett, stats, screen, ship, sb, aliens, bullets) gf.update_screen(sett, screen, stats, sb, ship, aliens, bullets, play_button)run_game()]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Python</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单线性回归和梯度下降]]></title>
    <url>%2F2019%2F07%2F16%2F%E7%AE%80%E5%8D%95%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%92%8C%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%2F</url>
    <content type="text"><![CDATA[一元线性回归 回归（Regression）一词简单来说，指的是：我们根据之前的数据预测出一个准确的输出值 线性回归（Liner Regression）：寻找一条直线，最大程度地拟合样本特征和样本输出标记之间的关系。样本特征只有一个，就被称为简单线性回归。 假设预测的线性函数的表达式为：h_\theta(x) = \theta_0 + \theta_1x其中$\theta_0 ，\theta_1$为此模型的参数（parameter）,分别对应于截距和斜率。我们所要做的是选择合适的参数使其最大程度地拟合我们的数据。 之后要用到的标记如下：$m$ 代表训练集中实例的数量$x$ 代表特征/输入变量$y$ 代表目标变量/输出变量$(x, y)$ 代表训练集中的实例$(x^{(i)},y^{(i)})$ 代表第$i$ 个观察实例 为了评估模型的准确程度，使这个值不受个别极端数据影响而产生巨大波动，我们选取 方差的二分之一 作为评判误差程度的标准，即： J(\theta_0,\theta_1) = \frac {1}{2m}\sum_{i=1}^{m}\ (h_\theta(x^{(i)}) - y^{(i)})^2$J(\theta_0,\theta_1)$ 即为该模型的代价函数（Cost Function），有时称为 损失函数（Loss Funtion） 于是乎我们的目标就变成了： minimize\ \ J(\theta_0,\theta_1) 与代价函数相对的一个概念为效用函数 （Utility Function） 通过分析问题，确定问题的代价函数或者效用函数，通过最优化获得机器学习的模型，是一类机器学习算法的基本思路，也是参数学习方法的基础。最小二乘法 最小二乘法是一种对该问题的最优化方法。 $J(\theta_0,\theta_1)$是一个多元函数。使其对各元的偏导数等于0，则可得该函数的极值。即： \frac{\partial J} {\partial \theta_0} = 0,\ \frac{\partial J} {\partial \theta_1} = 0接下来为求解过程： \frac{\partial J} {\partial \theta_0} = \frac {1}{2m} \sum ^{m}_{i=1}2(y^{(i)} - \theta_1x^{(i)} - \theta_0)(-1) = 0=> \sum ^{m}_{i=1}(y^{(i)} - \theta_1x^{(i)} - \theta_0) =0=>\sum ^{m}_{i=1} y^{(i)} - \theta_1 \sum ^{m}_{i=1}x^{(i)} - \sum ^{m}_{i=1}\theta_0 = 0 \=> \ \sum ^{m}_{i=1} y^{(i)} - \theta_1 \sum ^{m}_{i=1}x^{(i)} - m\theta_0 = 0=>（两边同时除以m） \ \theta_0 = \overline {y} \ - \ \theta_1 \overline{x} \ \ \ \ ① \frac{\partial J} {\partial \theta_1} = \frac {1}{2m}\sum ^{m}_{i=1}2(y^{(i)} - \theta_1x^{(i)} - \theta_0)(-x^{(i)}) = 0=> \sum ^{m}_{i=1}(y^{(i)} - \theta_1x^{(i)} - \theta_0)x^{(i)} =0（将①式代入其中）=> \sum ^{m}_{i=1}(y^{(i)} - \theta_1x^{(i)} -\overline {y} \ + \ \theta_1 \overline{x} )x^{(i)} =0=> \sum ^{m}_{i=1}y^{(i)} x^{(i)} - \theta_1(x^{(i)})^2 -\overline {y} x^{(i)} \ + \ \theta_1 \overline{x} x^{(i)} =0=> \sum ^{m}_{i=1}(y^{(i)} x^{(i)} -\overline {y} x^{(i)}) -\ \theta_1\sum ^{m}_{i=1}((x^{(i)})^2 - \ \overline{x} x^{(i)}) =0\theta_1 = \frac{\sum ^{m}_{i=1}(y^{(i)} x^{(i)} -\overline {y} x^{(i)})}{\sum ^{m}_{i=1}((x^{(i)})^2 - \ \overline{x} x^{(i)})}此式还可继续化简对于项$\sum ^{m}_{i=1}\overline{y} x^{(i)}$: = m\overline{y}\ \overline{x} = \overline{x}\sum ^{m}_{i=1}y^{(i)} = \sum ^{m}_{i=1}\overline{y}\ \overline{x}故这几项都可以互相转化，则有： 原式 = \frac{\sum ^{m}_{i=1}(y^{(i)} x^{(i)} -\overline {y} x^{(i)}-\overline{x}y^{(i)} + \overline{x}·\overline{y})}{\sum ^{m}_{i=1}((x^{(i)})^2 - \ \overline{x} x^{(i)})-\overline{x}x^{(i)}+\overline{x}^2)}=\frac{\sum ^{m}_{i=1}(x^{(i)}-\overline{x})(y^{(i)}-\overline{y})}{\sum ^{m}_{i=1}(x^{(i)} - \ \overline{x})^2} 综上，可得结论： \theta_1 = \frac{\sum ^{m}_{i=1}(x^{(i)}-\overline{x})(y^{(i)}-\overline{y})}{\sum ^{m}_{i=1}(x^{(i)} - \ \overline{x})^2}\theta_0 = \overline {y} \ - \ \theta_1 \overline{x}MATLAB实现：123a = polyfit(x, y, 1);h = polyval(a,x,1);plot(x,y,'*',x,h,'-'); polyfit(x, y, n)是matlab中用于曲线拟合的函数，其原理就是最小二乘法。第三个参数代表拟合的阶数。函数返回的是一个行矩阵:$[ \theta_n, \theta_{n-1}, \theta_{n-2},.. . ,\theta_0]$ 梯度下降 梯度下降是一个用来求函数最小值的算法，我们可以使用梯度下降算法来求出代价函数$J(\theta_0,\theta_1)$的最小值。 梯度下降的思想是：开始时我们随机选择一个参数的组合(𝜃0,𝜃1,……,𝜃𝑛)，计算代价函数，然后我们寻找下一个能让代价函数值下降最多的参数组合（即梯度）。我们持续这么做直到到到一个局部最小值（local minimum）。因为我们并没有尝试完所有的参数组合，所以不能确定我们得到的局部最小值是否便是全局最小值（global minimum）.选择不同的初始参数组合，可能会找到不同的局部最小值。 批量梯度下降（Batch gradient descent）的算法如下： repeat\ until\ convergence\ \{ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \\theta_j := \theta_j - \alpha \frac{\partial}{\partial \theta_j}J(\theta_0, \theta_1) \ \ \ for \ j = 0\ and \ 1\}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \其中α是学习率（learning rate），又可以说是步长，决定了我们沿着能让代价函数下降程度最大的方向迈出的步子有多大。 α的值不能取得太大，否则有很大可能“错过极小值”，无法收敛，甚至发散。但也不能太小，否则迭代次数会很大，影响效率 实际上，在梯度下降法中，当接近局部最低点时，梯度下降法会自动采取更小的幅度。这是因为当我们接近局部最低点时，很显然在局部最低时导数等于零，所以当我们接近局部最低时，导数值会自动变得越来越小，所以梯度下降将自动采取较小的幅度，所以我们没有必要在过程中另外再减少α的值 梯度下降的线性回归将梯度下降应用到刚刚的代价函数上，求其最小值。 \frac{\partial J} {\partial \theta_0} = \frac {1}{2m} \sum ^{m}_{i=1}2(y^{(i)} - \theta_1x^{(i)} - \theta_0)(-1)\ \\frac{\partial J} {\partial \theta_1} = \frac {1}{2m}\sum ^{m}_{i=1}2(y^{(i)} - \theta_1x^{(i)} - \theta_0)(-x^{(i)})故梯度下降算法可写成： Repeat\{ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \\theta_0 := \theta_0 - \alpha \frac {1}{m} \sum ^{m}_{i=1}(h_\theta(x^{(i)})-y^{(i)})\theta_1 := \theta_1 - \alpha \frac {1}{m} \sum ^{m}_{i=1}(h_\theta(x^{(i)})-y^{(i)})·x^{(i)}\}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 这个名字”批量梯度下降”，指的是在梯度下降的每一步中，我们都用到了所有的训练样本。在梯度下降中，在计算微分求导项时，我们需要进行求和运算，所以，在每一个单独的梯度下降中，我们最终都要对所有𝑚个训练样本求和。因此，批量梯度下降法这个名字说明了我们需要考虑所有这一”批”训练样本。而事实上，有时也有其他类型的梯度下降法，不是这种”批量”型的，不考虑整个的训练集，而是每次只关注训练集中的一些小的子集。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>机器学习</tag>
        <tag>线性回归</tag>
        <tag>梯度下降</tag>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记(九)：文件]]></title>
    <url>%2F2019%2F07%2F15%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B9%9D%2F</url>
    <content type="text"><![CDATA[第九章 文件 9.1 从文件中读取数据 9.1.1 读取整个文件12345pi.txt3.14159 26535 89793 123with open('pi.txt','r') as file_object: contents = file_object.read() print(contents) 输出：1233.14159 26535 89793 with open()可以不需要在访问文件后关闭，随着with的结束，文件会自动关闭 open()将目标文件打开，当做一个对象。 read()将文件中所有内容读取为一个长长的字符串 输出的文本最后有空行是因为read()达到文件尾时会返回一个空字符串。消除空行可用rstrip() 9.1.2 逐行读取123with open('pi.txt','r') as file_object: for line in file_object: print(line) 输出：123453.14159 26535 89793 每行之间都有一个空行，是因为文本文件每行结尾都有一个换行符,而print()每次都会自动换行，所以多了一个换行。 将print(line)改为print(line.rstrip())即可解决 9.1.3 创建一个包含文件各行内容的列表12345with open('pi.txt','r') as file_object: lines = file_object.readlines() for line in lines: print(line.strip()) readlines()读取文本中的每一行，并存储在一个列表里。调用len()可以获知文件内容的行数。这样可以让在with open结束后依然可以使用文本内容。 9.1.4 replace()替换字符串的内容123s = 'I Love C++'s.replace('C++','Python')print(s) I Love Python 9.2 写入文件 9.2.1 写入空文件12with open('filename', 'w') as fo: fo.write('I love you') 打开文件，会发现文件内容为： I love you 9.2.2 写入多行123with open('filename', 'w') as fo: fo.write('I love you') fo.write('I love you too') 打开文件，会发现文件内容为： I love youI love you too write()不会像print()一样自动换行，所以要自己添加换行符。 123with open('filename', 'w') as fo: fo.write('I love you\n') fo.write('I love you too') 9.2.3 在文件后附加内容就是打开模式改为’a’ 9.3 异常 9.3.1 ZeroDivisionError异常如果程序中出现除以0的情况，程序将会反馈Traceback错误信息：ZeroDivisionError 9.3.2 try-except 代码块当你认为可能发生错误时，可编写一个try-except代码块来处理可能引发的异常。 1234try: print(5/0)except: print("You can't divide by zero") 当try代码块出现异常时，Python将跳过try代码块而去执行except代码块。 9.3.3 else 代码块123456789num1 = 5num2 = int(input())answer = num1/num2try: print(5/0)except: print("You can't divide by zero")else: print(answer) -当try代码块执行成功时，将会接着执行else代码块 9.3.4 FileNotFoundError异常文件打开失败时会返回改错误 9.3.5 split()处理字符串split()函数将字符串根据空格分隔，并创建一个 单词列表123s = 'I love you'words = s.split()print(words) [‘I’, ‘love’, ‘you’] 调用len()函数即可以获知字符串单词个数。 9.3.6 处理多个文件有一种方法是将一系列文件名存在列表里：1234files = ['f1.txt', 'f2.txt', 'f3.txt']for filename in files: with open(filename): ... 9.3.7 使用pass语句跳过异常语句1234try: print(5/0)except: pass pass语句会让Python什么都不做，“一声不吭”。]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记(八)：类]]></title>
    <url>%2F2019%2F07%2F15%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%AB%2F</url>
    <content type="text"><![CDATA[第八章 类 8.1 创建和使用类 8.1.1 创建类123456789101112class Dog(): """模拟小狗的类""" def __init__(self, name, age): """ 初始化类信息""" self.name = name self.age = age def sit(self): print(self.name.title() + " sit down!") def roll(self): print(self.name.title() + " roll over!") 方法__init__() 类中的函数称为方法 ；你前面学到的有关函数的一切都适用于方法。 方法init()是一个特殊的方法，每当你根据Dog类创建新实例时，Python都会自动运行它。 在这个方法的名称里，开头和末尾都有两个下划线，这是一种约定，为了避免与普通方法名称冲突 该方法里有三个形参：self、 name和age。其中self是必不可少的，还必须放在所有参数前面。因为每个与类相关联的方法都调用都自动传递self,它是一个指向实例本身的引用，让实例能够访问类中的属性和方法。我们创建Dog实例时，Python将调用init()方法。我们通过实参向Dog()传递名字和年龄，而self会自动传递。所以每次我们只需要给最后两个形参（age和name）即可。 在方法init()的定义中，两个变量都有前缀self。以self为前缀的变量都可供类中的所有方法使用，可以通过类的任何实例访问这些量。self.name=name获取存储在形参name中的值，并存储到变量name中，然后该变量被关联到创建的实例。像这样可以通过实例访问的变量称为属性。 Dog类还定义了另外两个方法：sit()和roll()。由于这些方法不需要额外的信息，因此他们只有一个形参self。 8.1.2 根据类创建实例可将类视为有关如何创建实例的说明。12345678class Dog(): ...my_dog = Dog('Tim', 2)print("My dog's name is " + my_dog.name)print("My dog's age is " + str(my_dog.age))my_dog.sit()my_dog.roll() My dog’s name is TimMy dog’s age is 2Tim sit down!Tim roll over! 8.2 继承一个类继承另一个类时，它将自动获得另一个类的所有属性和方法 8.2.1 子类的方法 __init__()创建子类的实例时，Pyhton首先需要完成的是给父类的所有属性赋值。为此，子类的init方法需要父类“施以援手”。例如，下面来模拟电动汽车，其为继承自“车”的子类。1234567891011121314151617181920class Car(): def __init__(self, make, model, year): self.make = make self.model = model self.year = year def get_name(self): long_name = self.make + ' ' + self.model + ' ' + str(self.year) return long_name.title()class ElectricCar(Car): def __init__(self, make, model, year): super().__init__(make, model, year)my_tesla = ElectricCar('tesla', 'model', 2016)print(my_tesla.get_name()) Tesla Model 2016 定义子类时，必须在括号内指定父类的名称 super()是一个特殊的函数，帮助Python将父类和子类关联。这行代码让Python调用ElectricCar的父类的方法init()，让ElectricCar实例包含父类的所有属性。父类又称超类(super class)，super函数也是因此得名。 8.2.2 给子类定义属性和方法让一个类继承另一个类之后，可以拥有自己独特的属性。比如电动汽车有一项指标是电池容量1234567891011121314151617181920class Car(): def __init__(self, make, model, year): self.make = make self.model = model self.year = year ...class ElectricCar(Car): def __init__(self, make, model, year, batterysize): super().__init__(make, model, year) self.batterysize = batterysize def get_bat_size(self): return self.batterysizemy_tesla = ElectricCar('tesla', 'model', 2016, 70)print(my_tesla.get_bat_size()) 70 8.2.3 重写父类的方法对于父类的方法，只要不符合子类的”规则”，都可以进行重写。即在子类中定义一个重名的方法，这样Python将不会考虑父类中的这个方法。比如描述电动汽车的名字还需要带上电池容量，则需要重写get_name函数12345678910111213141516171819class Car(): ... def get_name(self): long_name = self.make + ' ' + self.model + ' ' + str(self.year) return long_name.title()class ElectricCar(Car): ... def get_name(self): long_name = self.make + ' ' + self.model + ' ' + str(self.year) + ' ' + str(self.batterysize) return long_name.title()my_tesla = ElectricCar('tesla', 'model', 2016, 70)print(my_tesla.get_name()) Tesla Model 2016 70 8.2.3 将类作为其他类的属性和C++类的嵌套相似，不多赘述 8.3 导入类 语法 作用 from 模块名 import 类名 导入单个类 from 模块名 import 类1，类2… 导入多个类 import 模块名 导入整个模块的类（使用需要加句点） from 模块名 import * 导入模块所有类 (使用不需要加句点) 8.3.1 在一个模块中导入另一个模块模块可以连环导入，比如 8.4 Python标准库Python标准库是Python内置的一组模块。只需在程序开头包含一条简单的import语句，便可使用标准库的函数和类。比如模块collections中的一个类——OrderedDict.字典虽然能够把信息关联，但不能记录你添加键值对的顺序。而OrderedDict可以解决这个问题。12345678910from collections import OrderedDictfav_lang = OrderedDict()fav_lang['Lily'] = 'C'fav_lang['Tom'] = 'Python'fav_lang['Jack'] = 'JAVA'for name, lang in fav_lang.items(): print(name + " " + lang) Lily CTom PythonJack JAVA 输出的顺序与添加的顺序完全相同。]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记(七)：函数]]></title>
    <url>%2F2019%2F07%2F14%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%83%2F</url>
    <content type="text"><![CDATA[第七章 函数 7.1 定义函数 12345def greeting(username): print("Hello, " + username + "!")greeting('Tom') # 调用函数 输出：Hello, Tom! 7.2 传递实参 向函数传递实参的方式很多，可使用 位置实参 ，这要求实参的顺序和形参的顺序相同；也可以使用 关键字实参 ，其中每个参数都由变量名和值组成；还可以使用列表和字典。 7.2.1 位置实参你调用函数时，Python必须将函数调用的每个实参都关联到函数定义中的一个形参。为此，最简单的关联方式是基于实参的顺序。这种方式被称为 位置实参 12345def best_book(book_name, book_type): print("The best book is " + book_name) print("It's a " + book_type)best_book("Lucy", "scientific") 输出： The best book is LucyIt’s a scientific 调用方式与C大体相同，不多赘述。 7.2.2 关键字实参 关键字实参 是传递给函数的 名称-值对。你直接在实参总将名称和值关联起来，因此向函数传递参数时不会混淆顺序。关键字实参让你无需考虑函数调用中的实参顺序，还清除指出各个值的用途。 12345def best_book(book_name, book_type): print("The best book is " + book_name) print("It's a " + book_type)best_book(book_type = "scientific", book_name = 'Lucy') 输出同上 7.2.3 默认值编写函数时，可以给每个形参指定默认值。123456def best_book(book_name, book_type='scientific'): print("The best book is " + book_name) print("It's a " + book_type)best_book(book_name='Lucy') 123456def best_book(book_name, book_type='scientific'): print("The best book is " + book_name) print("It's a " + book_type)best_book('Lucy') 输出皆为同上 有默认值的形参必须放在无默认值的形参后面（与C++相同） 7.3 返回值 123456def name(first_name, last_name): full_name = first_name + " " + last_name return full_name.title()me = name('Eion', 'Lee')print(me) Eion Lee 7.3.1 让实参变成可选的就上面的例子来说，考虑到有的人有中间名，有的人没有123456789101112def name(first_name, last_name, middle_name = ''): if middle_name: full_name = first_name + " " + middle_name + " " + last_name else: full_name = first_name + " " + last_name return full_name.title()me = name('Eion', 'Lee')you = name('TZ', 'BEX', 'F')print(me)print(you) Eion LeeTz F Bex 7.3.2 返回字典返回值可以是复杂的变量，比如字典和列表。1234567891011def person(fn, ln, gd): p = &#123; 'first_name': fn, 'last_name': ln, 'gender': gd &#125; return pT1 = person('Eion', 'Lee', 'male')print(T1) {‘first_name’: ‘Eion’, ‘last_name’: ‘Lee’, ‘gender’: ‘male’} 1234567def person(f, s, t): p = [f, s, t] return pT1 = person(1, 2, 3)print(T1) [1, 2, 3] 7.4 传递列表 将列表传递给函数非常有用。函数可以直接访问列表的内容，并对其进行修改。123456def greeting(names): for name in names: print("Hello, " + name + "!")guests = ['Tom','Alice','Bob']greeting(guests) Hello, Tom!Hello, Alice!Hello, Bob! 7.4.1 用函数修改列表12345678910111213def print_list(required): finished = [] while required: cur = required.pop() print(cur + " finished") finished.append(cur) return finishedre = ['Tom', 'Alice', 'Bob']fi = print_list(re)print("\nUninished:")print(re) Bob finishedAlice finishedTom finishedUninished:[] 7.4.2 禁止函数修改列表有时不需要函数修改列表。比如打印完后，还想查阅原来需要打印的名单，则不能让函数修改这份名单。为解决这个问题，可以向函数传递列表的副本，而不是原列表传递列表的副本可以这样做：1print_list(re[:]) 即： 将列表的完整切片传递给函数。★ 12345678910111213def print_list(required): finished = [] while required: cur = required.pop() print(cur + " finished") finished.append(cur) return finishedre = ['Tom', 'Alice', 'Bob']fi = print_list(re[:])print("\nRequired:")print(re) Bob finishedAlice finishedTom finishedRequired:[‘Tom’, ‘Alice’, ‘Bob’] 7.5 传递任意数量的参数 有时候，预先不知道要传递多少个实参。但Python允许函数从调用语句中收集任意数量的实参。例如，要计算若干个正数的和。下面的函数只有一个形参*nums,不管调用语句提供多少实参，这个形参都会把它们收入到一个元组中。12345678def summ(*nums): sum = 0 for i in nums: sum += i return sums = summ(1,2,3,4,5,6,7)print(s) 28 形参名*nums中的星号让Python创建一个名为nums的空元组，并将所有收到的参数都封装进去。12345678def summ(*nums): sum = 0 print(nums) for i in nums: sum += i return sums = summ(1,2,3,4,5,6,7) (1, 2, 3, 4, 5, 6, 7) 7.5.1 结合使用位置参数和任意数量实参如果要让函数接受不同类型的实参，必须在函数定义中将接纳任意数量的实参的形参放在最后。（仅对于位置参数） 1234567def pizza(size, *ingds): print("Size: " + str(size)) for ingd in ingds: print(" - " + ingd)pizza(12, 'pepper', 'tomato')pizza(14, 'potato') Size: 12- pepper- tomatoSize: 14- potato 7.5.2 使用任意数量的关键字实参有时候，需要接受任意数量的实参，但预先不知道传递给函数的是什么样的信息。在这种情况下，可将函数编写成能够接受任意数量的键-值对。比如要生成一份简历，但不知道会加入多少信息。12345678def profile(name, gender, **info): p = &#123;'name': name, 'gender': gender&#125; for key, value in info.items(): p[key] = value return pme = profile('Eion', 'male', age='18', job='stu')print(me) {‘name’: ‘Eion’, ‘gender’: ‘male’, ‘age’: ‘18’, ‘job’: ‘stu’} 形参名**info中的两个星号让Python创建一个名为info的空字典，并将所有收到的键值对都封装进去。 7.5.3 强制使用关键字实参将强制关键字参数放到某个*参数或者单个*后面就能达到这种效果。比如：12345def recv(maxsize, *, block): print('Receives a message')recv(1024, True) # TypeErrorrecv(1024, block = True) 在第一次调用中，True被当做星号的任意实参，导致没有参数传递给block，所以报错。利用这种技术，我们还能在接受任意多个位置参数的函数中指定关键字参数。比如：12345678def minimum(*values, clip=None): m = min(values) if clip is not None: m = clip if clip &gt; m else m return mminimum(1, 5, 2, -5, 10) # Returns -5minimum(1, 5, 2, -5, 10, clip=0) # Returns 0 7.6 将函数存储在模块中函数的有点之一是，使用它们可以将代码块与主程序分离。通过给函数指定描述性名称，可让主程序容易理解的多。你还可以更进一步，将函数存储在被称为模块的独立文件中，在将模块导入到主程序。import语句允许当前运行的程序文件中使用模块的代码。 7.6.1 导入整个模块123456789101112# func.pydef profile(name, gender, **info): p = &#123;'name': name, 'gender': gender&#125; for key, value in info.items(): p[key] = value return p-------------------------------------------------------------# main.pyimport funcme = func.profile('Eion', 'male', age='18', job='stu')print(me) {‘name’: ‘Eion’, ‘gender’: ‘male’, ‘age’: ‘18’, ‘job’: ‘stu’} 7.6.2 导入特定的函数还可以导入模块中的特定函数，语法如下：from 模块名 import 函数1, 函数2, ....通过逗号分隔多个函数 若用这种语法，则调用函数时不需要用句点指定模块名。 123456789101112# func.pydef profile(name, gender, **info): p = &#123;'name': name, 'gender': gender&#125; for key, value in info.items(): p[key] = value return p-------------------------------------------------------------# main.pyfrom func import profileme = profile('Eion', 'male', age='18', job='stu')print(me) 7.6.3 使用as给函数/模块指定别名1from func import profile as pf 1import func as fc 7.6.4 导入模块中的所有函数1from func import * 该语句中的星号让Python将模块func中的所有函数复制到这个程序文件中。 由于是导入函数，所以所有函数都不需要加句点调用。 但最好不要采用这种方法：如果遇到不同模块中有着相同名称的函数，则会出错。]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记(六)：输入与while循环]]></title>
    <url>%2F2019%2F07%2F13%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%85%AD%2F</url>
    <content type="text"><![CDATA[第六章 输入与while循环 6.1 函数input()的工作原理 函数input()让程序暂停运行，等待用户输入一些文本。获取用户输入后，Python将其存储在一个变量中。123name = ''name = input("who are you?")print("Hello, " + name + "!") who are you?输入：tim输出：Hello, tim! 函数input()接受一个参数：即要向用户展示的提示或说明。程序等待用户输入，在用户按回车键后继续运行。 6.1.1 用int()获取数值输入使用函数input()时，Python会将用户输入解读为字符串。可以使用int()函数，让Python将参数汇总的的字符串转化为数值。（与str()对应）12345age = ''age = input("How old are you?\n")age = int(age)if age &gt;= 18: print("You are an adult.") 输入：19输出：You are an adult. 6.2 while循环 1234num = 1while num &lt;= 5: print(num) num += 1 12345 1234s = input("i am a repeater\n")while s != 'quit' print(s) s = input() 复读机，直到用户输入quit停止 1234567flag = Truecount = 5while flag: print(count) count -= 1 if count &lt; 0: flag = False 543210 6.2.1 在循环中使用break和continue 12345while True: s = input() if s == 'quit': break print("You just inputed " + s) 复读机，直到输入quit continue不多赘述，与C语言作用相同 6.3 用while循环来处理列表和字典 6.3.1 在列表之间移动元素12345678910target = ['apple', 'bannana', 'peach']shopping_car = []while target: cur = target.pop() print("Buy " + cur) shopping_car.append(cur)print("You have bought these:")print(shopping_car)print("These not bought:")print(target) Buy peachBuy bannanaBuy appleYou have bought these:[‘peach’, ‘bannana’, ‘apple’]These not bought:[] 6.3.2 删除所有列表中的特定值1234fruits = ['apple', 'orange', 'peach', 'apple', 'apple']while 'apple' in fruits: fruits.remove('apple')print(fruits) [‘orange’, ‘peach’] 6.3.3 利用输入填充字典123456789cilent = &#123;&#125;while True: name = input("Please input your name:") nick_name = input("Please input your nickname:") cilent[nick_name] = name re = input("Would you like to continue? (yes/no)") if re == 'no': breakprint(cilent)]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记(五):字典]]></title>
    <url>%2F2019%2F07%2F13%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%94%2F</url>
    <content type="text"><![CDATA[第五章 字典 5.1 使用字典 在Python中，字典 是一系列 键-值对 。每个键都与一个值相关，可以用键值访问与之关联的值。用放在花括号{ }中的一系列键-值对表示字典。123456Tom = &#123; 'gender':'male', 'age' : 15, 'home':'New York'&#125;print(Tom['gender']) 输出： male 5.1.1 添加键值对字典是一种动态结构，可随时在其中添加键值对。要添加键值对，可依次指明字典名、用方括号括其键、将值赋值给它。1234567Tom = &#123; 'gender':'male', 'age' : 15, 'home':'New York'&#125;Tom['hobby'] = 'football'print(Tom) 输出： {‘gender’: ‘male’, ‘age’: 15, ‘home’: ‘New York’, ‘hobby’: ‘football’} 5.1.2 修改字典中的值直接赋值，不多赘述 5.1.3 删除键值对对于字典中不需要的信息，可以用del语句直接彻底删除1234567Tom = &#123; 'gender':'male', 'age' : 15, 'home':'New York'&#125;del Tom[age]print(Tom) {‘gender’: ‘male’, ‘home’: ‘New York’} 5.2 遍历字典 5.2.1 遍历字典所有信息1234567Tom = &#123; 'gender':'male', 'home':'New York'&#125;for key, value in Tom.items(): print("\nKey: " + key) print("Value: " + value) 要编写遍历字典的for循环，需要声明两个变量，用于存储键和值。 方法items()返回一个键值对列表。 5.2.2 遍历字典中所有的键在不需要使用字典中的值时，方法keys()很有用。123456Tom = &#123; 'gender':'male', 'home':'New York'&#125;for key in Tom.keys(): print("Key: " + key) Key: genderKey: home keys()返回一个键列表 5.2.3 遍历字典中所有的值同理，用方法values() 可以得到一个值列表123456Tom = &#123; 'gender':'male', 'home':'New York'&#125;for val in Tom.values(): print("Values: " + val) Values: maleValues: New York 5.3 嵌套* 字典、元组、列表之间可以相互嵌套比如：123456a = [1, 2]b = [3, 4]c = &#123; 1: a, 2: b&#125; 123a = &#123;1: 10, 2: 20&#125;b = &#123;3: 30&#125;c = [a, b] 但需要注意： 被嵌套的字典、列表、元组并不是复制一套新副本进去，而是将其“引用”被包含进去。即改变被包含的元素，原列表/元组/字典同样会改变。 被包含的简单变量不会变化 1234567891011#字典包含列表a = [1, 2]b = [3, 4]c = &#123; 1: a, 2: b&#125;c[1][0] = 3print(c[1])print(a) c[1] : [3, 2]a : [3, 2] 12345678#列表包含字典a = &#123;1: 10, 2: 20&#125;b = &#123;3: 30&#125;c = [a, b]c[0][1] = 100print(c[0])print(a) c[0] : {1: 100, 2: 20}a : {1: 100, 2: 20} 123456#列表包含简单变量i = 1a = [i, 2]a[0] = 2print(a[0])print(i) a[0] : 2i : 1]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记(四)：if语句]]></title>
    <url>%2F2019%2F07%2F12%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[第四章 if语句 4.1 条件测试 4.1.1 检查是否相等1234car = 'bmw'print(car == 'bmw')print(car == 'byd')print(car != 'byd') 输出结果： TrueFalseTrue == 等于 != 不等于 &gt;, &gt;=, &lt;, &lt;= 大小于等于 4.1.2 检查多个条件1234car = 'bmw'phone = 'iphone'print(car == 'bmw' and phone == 'iphone')print(car == 'byd' or phone == 'samsung') TrueFalse and 逻辑且 or 逻辑或 4.1.3 检查特定值是否在列表中123nums = [10, 20, 30]print(30 in nums)print(40 not in nums) TrueTrue in 在列表中 not in不在列表中 4.1.4 布尔表达式12flag = Trueflag = False 不多赘述 4.2 if语句 1234age = 15if age &gt;= 18: print("You are old enough") print("You can vote now") 没有输出结果Python的if语句不需要加括号。注意冒号 4.2.1 if-else语句1234567age = 15if age &gt;= 18: print("You are old enough") print("You can vote now")else: print("You are too young") print("Please wait for " + str(18-age) + " year(s)") 输出结果: You are too youngPlease wait for 3 year(s) 4.2.2 if-elif-else语句1234567age = 15if age &gt;= 18: print("You are an adult")elif age &gt;= 12: print("You are a teenager")else: print("You are a child") 输出结果： You are a teenager 4.2.3 检查列表是否为空12345nums = []if nums: print("list is not empty")else: print("list is empty") 输出为： list is empty 4.2.4 if语句与布尔表达式12345flag = Trueif flag: print("YES")else: print("NO") 输出： YES 不多赘述]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记(三)：操作列表]]></title>
    <url>%2F2019%2F07%2F12%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[第三章 操作列表 3.1 遍历整个列表 我们可以用for循环遍历整个列表：123fruits = ['apple', 'banana', 'orange']for i in fruits: print(i) 输出结果： applebananaorange 不要忘了冒号 3.1.1 深入研究循环 ① 在上述循环中，程序先读到这一行代码1for i in fruits: 这让Python从列表中获取第一个元素’apple’ ，将其赋值给 i ② 接着程序执行循环体中的语句：1print(i) 由此将i的值（即’apple’）打印出来③ 程序总共重复上述步骤三次，结束循环 需要注意的是，循环过程中，是将列表的元素赋值给循环标记（i）的 如下代码可以体现这一点：12345fruits = ['apple', 'banana', 'orange']for i in fruits: i = i.title() print(i)print(fruits) 输出结果为： AppleBananaOrange[‘apple’, ‘banana’, ‘orange’] 原列表中的元素并没有因i的改变而发生变化 3.1.2 在循环中执行更多操作在一次迭代中可以执行无数句语句，只需将它们按相同格式缩进即可：12345fruits = ['apple', 'banana', 'orange']for i in fruits: print(i) print("I love " + i.title())print("I love them all!") 输出结果： appleI love ApplebananaI love BananaorangeI love OrangeI love them all! 3.2 创建数值列表 3.2.1 使用函数range()range() 函数可以生产一系列连续的数字12for i in range(1, 11, 2): print(i) 输出结果： 23 range(a, b)生成的区间为 a ~ (b-1) range()生成的不是列表 range()函数还可以指定步长：12for i in range(1, 11, 2): print(i) 输出结果： 13579 3.2.2 使用list()和range()函数创建数值列表可以使用函数list()将range()转化成数字列表：1print(list(range(1, 4))) 输出结果： [1, 2, 3] 3.2.3 max()，min()，sum()函数将数字列表名称作为函数max()的参数，返回列表中的最大值同理min()返回最小值，sum()返回列表所有元素的和 1234nums = [1, 2, 3, 10]print(max(nums))print(min(nums))print(sum(nums)) 输出结果： 10116 3.2.4 列表解析*用前面介绍的方式形成一个平方列表：123for i in range(1,11) squares.append(i**2)print(squares) 输出结果为： [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 使用列表解析，可以一行之内完成上述代码：12squares = [i ** 2 for i in range(1, 11)]print(squares) 输出结果同上 使用这种语法, 首先指定一个描述性的列表名，如square； 然后指定一个左方括号，并定义一个表达式。在这里表达式为 i ** 2 接着编写一个for循环，给表达式提供值（此处没有冒号），并加上右方括号 3.3 使用列表的一部分：切片 要创建切片，可指定要使用的第一个元素和最后一个元素的索引，和range一样，最后一个元素不取 12fruits = ['apple', 'banana', 'orange']print(fruits[0:2]) 输出结果为： [‘apple’, ‘banana’] 如果没有指定起始索引，如 fruit[:2]，则默认从列表开头开始 同理如果没有指定结束为止，如 fruit[2:]，则默认到列表尾结束 fruit[-2:] 表示从倒数第二个到最后一个的切片 3.4 复制列表 123my_fruits = ['apple', 'banana', 'orange']your_fruits = my_fruits #尽量不要这么复制print(your_fruits) [‘apple’, ‘banana’, ‘orange’] 可直接将列表名赋值给新列表，以达到复制的效果。 但尽量不要这么做！1234my_fruits = ['apple', 'banana', 'orange']your_fruits = my_fruitsmy_fruits.append('peach')print(your_fruits) [‘apple’, ‘banana’, ‘orange’, ‘peach’] 可以发现，在将my_fruits赋值给your_fruit后，在my列表后添加了新元素，your列表后也同样出现了这个新元素.说明，被赋值的新列表和原列表用的同一个列表，新列表 是跟着 原列表 一起改变的（类似于C++里的引用） * 比较正确规范的做法是将切片复制给新列表&lt;/u&gt;,这样是将新的副本复制给新列表 1234my_fruits = ['apple', 'banana', 'orange']your_fruits = my_fruits[:]my_fruits.append('peach')print(your_fruits) 输出结果为： [‘apple’, ‘banana’, ‘orange’] 新列表并没有发生改变 3.5 元组 列表是可以修改的。然而有时候需要创建一系列不可修改的元素，元组 可以满足这种需求。 3.5.1 定义元组元组使用圆括号来标识，同样可以用索引来访问其值。123dim = (200, 50)print(dim[0])print(dim[1]) 20050 3.5.2 遍历元组和遍历链表一样，不多赘述 3.5.3 修改元组变量虽然不能修改元组的元素，但可以给存储元组的变量(比如此处的dim)赋值。因此，需要通过重新定义的方法修改元组：1234dim = (200, 50)print(dim)dim = (2,5)print(dim) 输出结果为： (200, 50)(2, 5) 给元组变量赋值的操作是合法的]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记(二)：列表]]></title>
    <url>%2F2019%2F07%2F11%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[第二章 列表简介 2.1 列表 列表 由一系列元素按特定顺序排列组成。 在Python中，用方括号（ [ ] ）来表示列表，并用逗号分隔其中的元素。12fruits = ['apple', 'banana', 'orange']print(fruits) 如果将列表打印出来，Python将打印列表的内部表示，包括方括号。输出结果： [‘apple’, ‘banana’, ‘orange’] 2.1.1 访问列表元素列表是有序集合，要访问列表元素，只需像C语言中的数组一样，将元素的索引或位置表示出来即可。例如：12fruits = ['apple', 'banana', 'orange']print(fruits[0]) 输出结果： apple 可以发现列表的索引与数组一样都是从0开始的。 但Python还提供了一种特殊语法，索引-1返回倒数第一个元素。所以一个长度为a的列表索引取值范围为：[ -a, a-1] 2.2 修改、添加和删除元素 2.1.1 修改可直接用赋值的方法修改列表的元素123fruits = ['apple', 'banana', 'orange']fruits[1] = "peach"print(fruits[1]) 2.2.2 添加1.在列表末尾添加元素123fruits = ['apple', 'banana', 'orange']fruits.append('peach')print(fruits) 输出结果为： [‘apple’, ‘banana’, ‘orange’, ‘peach’] 方法append()会将参数的元素添加到列表末尾，而不影响其他元素 2.在列表中插入元素使用insert()可在列表中的任何位置插入新的元素。为此需要指定新元素和索引的值。123fruits = ['apple', 'banana', 'orange']fruits.insert(2,'peach')print(fruits) 在此示例中，insert(2, ‘peach’) 将新元素: ‘peach’（第二个参数）插入到原列表的第2个位置（第一个参数）；同时，从原来第2个位置往后的所有元素后移一位。 2.2.3 删除1.使用del语句删除元素如果已知所需删除的元素的位置，可以使用del语句123fruits = ['apple', 'banana', 'orange']del fruits[0]print(fruits) 输出结果为： [‘banana’, ‘orange’] 2.使用方法pop()删除元素有时候需要将元素从列表中删除，并接着使用它的值。 ① 方法pop()可删除列表末尾的元素，并返回其值（类比弹出栈的栈顶元素）123456fruits = ['apple', 'banana', 'orange']print(fruits)popped_fruit = fruits.pop()print(popped_fruit)print(fruits) 输出结果为： [‘apple’, ‘banana’, ‘orange’]orange[‘apple’, ‘banana’] ② pop()可以在括号中加入参数，表示要删除的元素的索引1234fruits = ['apple', 'banana', 'orange']popped_fruit = fruits.pop(2)print(popped_fruit) 输出结果为： orange 3.根据值使用remove方法删除元素有时候，我们不知道所需删除的元素的具体位置，只知道需要删除的元素的值，可以使用方法remove()1234fruits = ['apple', 'banana', 'orange', 'apple']print(fruits)fruits.remove('apple')print(fruits) 输出结果为： [‘apple’, ‘banana’, ‘orange’, ‘apple’][‘banana’, ‘orange’, ‘apple’] 注意: remove只能删除第一个指定的元素 2.3 组织列表 2.3.1 使用方法sort()对列表永久性排序1234fruits = ['banana', 'orange', 'apple']print(fruits)fruits.sort()print(fruits) 输出结果为： [‘banana’, ‘orange’, ‘apple’][‘apple’, ‘banana’, ‘orange’] 使用sort()之后，列表元素的顺序发生了永久性的变化 如果要按相反顺序排序列表，可以向sort()方法传递参数reverse = True123fruits = ['banana', 'orange', 'apple']fruits.sort(reverse = True)print(fruits) 输出结果为： [‘orange’, ‘banana’, ‘apple’] 2.3.2 使用函数sorted()对列表暂时性排序12345678fruits = ['banana', 'orange', 'apple']print("Here is the original list:")print(fruits)print("\nHere is the sorted list:")print(sorted(fruits))print("\nHere is the original list again:")print(fruits) 输出结果为： Here is the original list:[‘banana’, ‘orange’, ‘apple’] Here is the sorted list:[‘apple’, ‘banana’, ‘orange’] Here is the original list again:[‘banana’, ‘orange’, ‘apple’] 可见使用sorted后，列表元素的顺序并没有发生改变，sorted函数返回的是排序过的新列表 同样，可以向sorted()函数传递参数reverse = True 使其反向排序 2.3.3 倒着打印列表翻转列表元素的排列顺序，可以使用方法reverse()123fruits = ['banana', 'orange', 'apple']fruits.reverse()print(fruits) 输出结果为： [‘apple’, ‘orange’, ‘banana’] 可见方法reverse()永久性地改变了列表元素的排列顺序，翻转了原来的列表元素顺序 2.3.4 确定列表的长度使用函数len()可以快速得到列表的长度。12fruits = ['banana', 'orange', 'apple']print(len(fruits)) 输出结果为: 3]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记(一)：变量和简单数据类型]]></title>
    <url>%2F2019%2F07%2F10%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[第一章 变量和简单数据类型 1.1 变量的使用和命名 12message = "Hello World"print(message) 运行结果： Hello World 变量命名规则： 变量名只能包含字母、数字、下划线 变量名可以字母或者下划线打头，但不能以数字打头 不能将Python关键字当做变量名 1.2 字符串 字符串 就是一新系列字符。在Python中，用引号括起来的都是字符串。其中引号可以是单引号，也可是双引号，这使得你能够在字符串中包含引号和撇号。 例如:1234"This's a string"'This is also a string''I told you, "Python is the best in the world!" '"It's beautiful." 1.2.1 使用方法修改字符串的大小写 123456name = "ada lovelace"print(name.title())name = "ADa"print(name.title())print(name.upper())print(name.lower()) 输出结果： Ada LovelaceAdaADAada 方法 是Python可对数据进行的操作。 方法title()以首字母大写的方式显示每个单词。 方法upper()以大写显示所有字母字符 方法lower()以小写显示所有字符字母 1.2.2 合并（拼接）字符串12345first_name = "ada"second_name = "lovelace"full_name = first_name + " " + second_nameprint(full_name)print(full_name*3) 输出结果： ada lovelaceada lovelaceada lovelaceada lovelace Python用 加号 (+)和乘号 (*) 来合并字符串。这种合并方法称为 拼接 。 e.g:123#接上代码message = "Hello, " + full_name.title() + "!"print(message) 输出结果： Hello, Ada Lovelace! 1.2.3 删除空白12345s = " python "print(s.lstrip())print(s.rstrip())print(s.strip())print(s) 输出结果： python· （·代表空格）·pythonpython·python· 空白 泛指任何非打印字符，包括空格、制表符和换行符。 方法strip()删除字符串首尾空格。 方法lstrip()删除字符串首空格。 方法rstrip()删除字符串尾空格。 可以发现，在使用过这些方法后，原字符串并没有发生相应的变化 1.3 数字 1.3.1 整数Python使用两个乘号表示乘法运算1234&gt;&gt;&gt; 3 ** 29&gt;&gt;&gt; 3 ** 327 1.3.2 浮点数这个没什么好讲的 1.3.3 函数str()在字符串中需要用到数字变量的值时12345678age = 25print("Happy " + age + "th Birthday") #这种写法是错误的------------------------------------------------------------返回错误报告：Traceback (most recent call last): File "D:/Pytest/1.py", line 2, in &lt;module&gt; print("Happy " + age + "th Birthday") TypeError: can only concatenate str (not "int") to str 之所以会出现这样的错误，是因为类型不匹配Python无法将 int 和 str 类型的变量拼接在一起 为此可以调用str()函数，将非字符串变量表示为字符串12age = 25print("Happy " + str(age) + "th Brithday") 输出结果为： Happy 25th Birthday]]></content>
      <categories>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随便写写]]></title>
    <url>%2F2019%2F06%2F15%2F%E9%9A%8F%E4%BE%BF%E5%86%99%E5%86%99%2F</url>
    <content type="text"><![CDATA[使用 Ctrl+Alt+Del 重启电脑 f'(x_0)=\lim_{\Delta x\to 0} \frac{f(x_0+\Delta x) - f(x_0)}{\Delta x}\begin{equation}\begin{split}H(Y|X)&amp;=\sum_{x\in X} p(x)H(Y|X)\\&amp;=-\sum_{x\in X} p(x)\sum_{y\in Y}p(y|x)\log p(y|x)\\&amp;=-\sum_{x\in X} \sum_{y\in Y}p(y,x)\log p(y|x)\end{split}\end{equation} \frac{\partial J} {\partial \theta_0} = \sum ^{m}_{i=1}2(y^{(i)} - \theta_1x^{(i)} - \theta_0)(-1) = 0=> \sum ^{m}_{i=1}(y^{(i)} - \theta_1x^{(i)} - \theta_0) =0=>\sum ^{m}_{i=1} y^{(i)} - \theta_1 \sum ^{m}_{i=1}x^{(i)} - \sum ^{m}_{i=1}\theta_0 = 0 \ => \ \sum ^{m}_{i=1} y^{(i)} - \theta_1 \sum ^{m}_{i=1}x^{(i)} - m\theta_0 = 0=>（两边同时除以m） \ \theta_0 = \overline {y} \ - \ \theta_1 \overline{x}]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F14%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
